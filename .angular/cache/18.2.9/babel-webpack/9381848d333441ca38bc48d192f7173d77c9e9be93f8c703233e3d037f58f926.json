{"ast":null,"code":"import { SelectionModel, isDataSource } from '@angular/cdk/collections';\nimport { isObservable, Subject, BehaviorSubject, of, combineLatest, EMPTY, concat } from 'rxjs';\nimport { take, filter, takeUntil, startWith, tap, switchMap, map, reduce, concatMap, distinctUntilChanged } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Directive, Inject, Optional, inject, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, ViewChild, ContentChildren, EventEmitter, ChangeDetectorRef, booleanAttribute, Output, numberAttribute, NgModule } from '@angular/core';\nimport { TREE_KEY_MANAGER } from '@angular/cdk/a11y';\nimport * as i2 from '@angular/cdk/bidi';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { coerceObservable } from '@angular/cdk/coercion/private';\n\n/**\n * Base tree control. It has basic toggle/expand/collapse operations on a single data node.\n *\n * @deprecated Use one of levelAccessor or childrenAccessor. To be removed in a future version.\n * @breaking-change 21.0.0\n */\nclass BaseTreeControl {\n  constructor() {\n    /** A selection model with multi-selection to track expansion status. */\n    this.expansionModel = new SelectionModel(true);\n  }\n  /** Toggles one single data node's expanded/collapsed state. */\n  toggle(dataNode) {\n    this.expansionModel.toggle(this._trackByValue(dataNode));\n  }\n  /** Expands one single data node. */\n  expand(dataNode) {\n    this.expansionModel.select(this._trackByValue(dataNode));\n  }\n  /** Collapses one single data node. */\n  collapse(dataNode) {\n    this.expansionModel.deselect(this._trackByValue(dataNode));\n  }\n  /** Whether a given data node is expanded or not. Returns true if the data node is expanded. */\n  isExpanded(dataNode) {\n    return this.expansionModel.isSelected(this._trackByValue(dataNode));\n  }\n  /** Toggles a subtree rooted at `node` recursively. */\n  toggleDescendants(dataNode) {\n    this.expansionModel.isSelected(this._trackByValue(dataNode)) ? this.collapseDescendants(dataNode) : this.expandDescendants(dataNode);\n  }\n  /** Collapse all dataNodes in the tree. */\n  collapseAll() {\n    this.expansionModel.clear();\n  }\n  /** Expands a subtree rooted at given data node recursively. */\n  expandDescendants(dataNode) {\n    let toBeProcessed = [dataNode];\n    toBeProcessed.push(...this.getDescendants(dataNode));\n    this.expansionModel.select(...toBeProcessed.map(value => this._trackByValue(value)));\n  }\n  /** Collapses a subtree rooted at given data node recursively. */\n  collapseDescendants(dataNode) {\n    let toBeProcessed = [dataNode];\n    toBeProcessed.push(...this.getDescendants(dataNode));\n    this.expansionModel.deselect(...toBeProcessed.map(value => this._trackByValue(value)));\n  }\n  _trackByValue(value) {\n    return this.trackBy ? this.trackBy(value) : value;\n  }\n}\n\n/**\n * Flat tree control. Able to expand/collapse a subtree recursively for flattened tree.\n *\n * @deprecated Use one of levelAccessor or childrenAccessor instead. To be removed in a future\n * version.\n * @breaking-change 21.0.0\n */\nclass FlatTreeControl extends BaseTreeControl {\n  /** Construct with flat tree data node functions getLevel and isExpandable. */\n  constructor(getLevel, isExpandable, options) {\n    super();\n    this.getLevel = getLevel;\n    this.isExpandable = isExpandable;\n    this.options = options;\n    if (this.options) {\n      this.trackBy = this.options.trackBy;\n    }\n  }\n  /**\n   * Gets a list of the data node's subtree of descendent data nodes.\n   *\n   * To make this working, the `dataNodes` of the TreeControl must be flattened tree nodes\n   * with correct levels.\n   */\n  getDescendants(dataNode) {\n    const startIndex = this.dataNodes.indexOf(dataNode);\n    const results = [];\n    // Goes through flattened tree nodes in the `dataNodes` array, and get all descendants.\n    // The level of descendants of a tree node must be greater than the level of the given\n    // tree node.\n    // If we reach a node whose level is equal to the level of the tree node, we hit a sibling.\n    // If we reach a node whose level is greater than the level of the tree node, we hit a\n    // sibling of an ancestor.\n    for (let i = startIndex + 1; i < this.dataNodes.length && this.getLevel(dataNode) < this.getLevel(this.dataNodes[i]); i++) {\n      results.push(this.dataNodes[i]);\n    }\n    return results;\n  }\n  /**\n   * Expands all data nodes in the tree.\n   *\n   * To make this working, the `dataNodes` variable of the TreeControl must be set to all flattened\n   * data nodes of the tree.\n   */\n  expandAll() {\n    this.expansionModel.select(...this.dataNodes.map(node => this._trackByValue(node)));\n  }\n}\n\n/**\n * Nested tree control. Able to expand/collapse a subtree recursively for NestedNode type.\n *\n * @deprecated Use one of levelAccessor or childrenAccessor instead. To be removed in a future\n * version.\n * @breaking-change 21.0.0\n */\nclass NestedTreeControl extends BaseTreeControl {\n  /** Construct with nested tree function getChildren. */\n  constructor(getChildren, options) {\n    super();\n    this.getChildren = getChildren;\n    this.options = options;\n    if (this.options) {\n      this.trackBy = this.options.trackBy;\n    }\n    if (this.options?.isExpandable) {\n      this.isExpandable = this.options.isExpandable;\n    }\n  }\n  /**\n   * Expands all dataNodes in the tree.\n   *\n   * To make this working, the `dataNodes` variable of the TreeControl must be set to all root level\n   * data nodes of the tree.\n   */\n  expandAll() {\n    this.expansionModel.clear();\n    const allNodes = this.dataNodes.reduce((accumulator, dataNode) => [...accumulator, ...this.getDescendants(dataNode), dataNode], []);\n    this.expansionModel.select(...allNodes.map(node => this._trackByValue(node)));\n  }\n  /** Gets a list of descendant dataNodes of a subtree rooted at given data node recursively. */\n  getDescendants(dataNode) {\n    const descendants = [];\n    this._getDescendants(descendants, dataNode);\n    // Remove the node itself\n    return descendants.splice(1);\n  }\n  /** A helper function to get descendants recursively. */\n  _getDescendants(descendants, dataNode) {\n    descendants.push(dataNode);\n    const childrenNodes = this.getChildren(dataNode);\n    if (Array.isArray(childrenNodes)) {\n      childrenNodes.forEach(child => this._getDescendants(descendants, child));\n    } else if (isObservable(childrenNodes)) {\n      // TypeScript as of version 3.5 doesn't seem to treat `Boolean` like a function that\n      // returns a `boolean` specifically in the context of `filter`, so we manually clarify that.\n      childrenNodes.pipe(take(1), filter(Boolean)).subscribe(children => {\n        for (const child of children) {\n          this._getDescendants(descendants, child);\n        }\n      });\n    }\n  }\n}\n\n/**\n * Injection token used to provide a `CdkTreeNode` to its outlet.\n * Used primarily to avoid circular imports.\n * @docs-private\n */\nconst CDK_TREE_NODE_OUTLET_NODE = new InjectionToken('CDK_TREE_NODE_OUTLET_NODE');\n/**\n * Outlet for nested CdkNode. Put `[cdkTreeNodeOutlet]` on a tag to place children dataNodes\n * inside the outlet.\n */\nclass CdkTreeNodeOutlet {\n  constructor(viewContainer, _node) {\n    this.viewContainer = viewContainer;\n    this._node = _node;\n  }\n  static {\n    this.ɵfac = function CdkTreeNodeOutlet_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNodeOutlet)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(CDK_TREE_NODE_OUTLET_NODE, 8));\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkTreeNodeOutlet,\n      selectors: [[\"\", \"cdkTreeNodeOutlet\", \"\"]],\n      standalone: true\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkTreeNodeOutlet, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkTreeNodeOutlet]',\n      standalone: true\n    }]\n  }], () => [{\n    type: i0.ViewContainerRef\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [CDK_TREE_NODE_OUTLET_NODE]\n    }, {\n      type: Optional\n    }]\n  }], null);\n})();\n\n/** Context provided to the tree node component. */\nclass CdkTreeNodeOutletContext {\n  constructor(data) {\n    this.$implicit = data;\n  }\n}\n/**\n * Data node definition for the CdkTree.\n * Captures the node's template and a when predicate that describes when this node should be used.\n */\nclass CdkTreeNodeDef {\n  /** @docs-private */\n  constructor(template) {\n    this.template = template;\n  }\n  static {\n    this.ɵfac = function CdkTreeNodeDef_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNodeDef)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkTreeNodeDef,\n      selectors: [[\"\", \"cdkTreeNodeDef\", \"\"]],\n      inputs: {\n        when: [0, \"cdkTreeNodeDefWhen\", \"when\"]\n      },\n      standalone: true\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkTreeNodeDef, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkTreeNodeDef]',\n      inputs: [{\n        name: 'when',\n        alias: 'cdkTreeNodeDefWhen'\n      }],\n      standalone: true\n    }]\n  }], () => [{\n    type: i0.TemplateRef\n  }], null);\n})();\n\n/**\n * Returns an error to be thrown when there is no usable data.\n * @docs-private\n */\nfunction getTreeNoValidDataSourceError() {\n  return Error(`A valid data source must be provided.`);\n}\n/**\n * Returns an error to be thrown when there are multiple nodes that are missing a when function.\n * @docs-private\n */\nfunction getTreeMultipleDefaultNodeDefsError() {\n  return Error(`There can only be one default row without a when predicate function.`);\n}\n/**\n * Returns an error to be thrown when there are no matching node defs for a particular set of data.\n * @docs-private\n */\nfunction getTreeMissingMatchingNodeDefError() {\n  return Error(`Could not find a matching node definition for the provided node data.`);\n}\n/**\n * Returns an error to be thrown when there is no tree control.\n * @docs-private\n */\nfunction getTreeControlMissingError() {\n  return Error(`Could not find a tree control, levelAccessor, or childrenAccessor for the tree.`);\n}\n/**\n * Returns an error to be thrown when there are multiple ways of specifying children or level\n * provided to the tree.\n * @docs-private\n */\nfunction getMultipleTreeControlsError() {\n  return Error(`More than one of tree control, levelAccessor, or childrenAccessor were provided.`);\n}\n\n/**\n * CDK tree component that connects with a data source to retrieve data of type `T` and renders\n * dataNodes with hierarchy. Updates the dataNodes when new data is provided by the data source.\n */\nclass CdkTree {\n  /**\n   * Provides a stream containing the latest data array to render. Influenced by the tree's\n   * stream of view window (what dataNodes are currently on screen).\n   * Data source can be an observable of data array, or a data array to render.\n   */\n  get dataSource() {\n    return this._dataSource;\n  }\n  set dataSource(dataSource) {\n    if (this._dataSource !== dataSource) {\n      this._switchDataSource(dataSource);\n    }\n  }\n  constructor(_differs, _changeDetectorRef) {\n    this._differs = _differs;\n    this._changeDetectorRef = _changeDetectorRef;\n    this._dir = inject(Directionality);\n    /** Subject that emits when the component has been destroyed. */\n    this._onDestroy = new Subject();\n    /** Level of nodes */\n    this._levels = new Map();\n    /** The immediate parents for a node. This is `null` if there is no parent. */\n    this._parents = new Map();\n    /**\n     * Nodes grouped into each set, which is a list of nodes displayed together in the DOM.\n     *\n     * Lookup key is the parent of a set. Root nodes have key of null.\n     *\n     * Values is a 'set' of tree nodes. Each tree node maps to a treeitem element. Sets are in the\n     * order that it is rendered. Each set maps directly to aria-posinset and aria-setsize attributes.\n     */\n    this._ariaSets = new Map();\n    // TODO(tinayuangao): Setup a listener for scrolling, emit the calculated view to viewChange.\n    //     Remove the MAX_VALUE in viewChange\n    /**\n     * Stream containing the latest information on what rows are being displayed on screen.\n     * Can be used by the data source to as a heuristic of what data should be provided.\n     */\n    this.viewChange = new BehaviorSubject({\n      start: 0,\n      end: Number.MAX_VALUE\n    });\n    /**\n     * Maintain a synchronous cache of flattened data nodes. This will only be\n     * populated after initial render, and in certain cases, will be delayed due to\n     * relying on Observable `getChildren` calls.\n     */\n    this._flattenedNodes = new BehaviorSubject([]);\n    /** The automatically determined node type for the tree. */\n    this._nodeType = new BehaviorSubject(null);\n    /** The mapping between data and the node that is rendered. */\n    this._nodes = new BehaviorSubject(new Map());\n    /**\n     * Synchronous cache of nodes for the `TreeKeyManager`. This is separate\n     * from `_flattenedNodes` so they can be independently updated at different\n     * times.\n     */\n    this._keyManagerNodes = new BehaviorSubject([]);\n    this._keyManagerFactory = inject(TREE_KEY_MANAGER);\n    this._viewInit = false;\n  }\n  ngAfterContentInit() {\n    this._initializeKeyManager();\n  }\n  ngAfterContentChecked() {\n    this._updateDefaultNodeDefinition();\n    this._subscribeToDataChanges();\n  }\n  ngOnDestroy() {\n    this._nodeOutlet.viewContainer.clear();\n    this.viewChange.complete();\n    this._onDestroy.next();\n    this._onDestroy.complete();\n    if (this._dataSource && typeof this._dataSource.disconnect === 'function') {\n      this.dataSource.disconnect(this);\n    }\n    if (this._dataSubscription) {\n      this._dataSubscription.unsubscribe();\n      this._dataSubscription = null;\n    }\n    // In certain tests, the tree might be destroyed before this is initialized\n    // in `ngAfterContentInit`.\n    this._keyManager?.destroy();\n  }\n  ngOnInit() {\n    this._checkTreeControlUsage();\n    this._initializeDataDiffer();\n  }\n  ngAfterViewInit() {\n    this._viewInit = true;\n  }\n  _updateDefaultNodeDefinition() {\n    const defaultNodeDefs = this._nodeDefs.filter(def => !def.when);\n    if (defaultNodeDefs.length > 1 && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getTreeMultipleDefaultNodeDefsError();\n    }\n    this._defaultNodeDef = defaultNodeDefs[0];\n  }\n  /**\n   * Sets the node type for the tree, if it hasn't been set yet.\n   *\n   * This will be called by the first node that's rendered in order for the tree\n   * to determine what data transformations are required.\n   */\n  _setNodeTypeIfUnset(nodeType) {\n    if (this._nodeType.value === null) {\n      this._nodeType.next(nodeType);\n    }\n  }\n  /**\n   * Switch to the provided data source by resetting the data and unsubscribing from the current\n   * render change subscription if one exists. If the data source is null, interpret this by\n   * clearing the node outlet. Otherwise start listening for new data.\n   */\n  _switchDataSource(dataSource) {\n    if (this._dataSource && typeof this._dataSource.disconnect === 'function') {\n      this.dataSource.disconnect(this);\n    }\n    if (this._dataSubscription) {\n      this._dataSubscription.unsubscribe();\n      this._dataSubscription = null;\n    }\n    // Remove the all dataNodes if there is now no data source\n    if (!dataSource) {\n      this._nodeOutlet.viewContainer.clear();\n    }\n    this._dataSource = dataSource;\n    if (this._nodeDefs) {\n      this._subscribeToDataChanges();\n    }\n  }\n  _getExpansionModel() {\n    if (!this.treeControl) {\n      this._expansionModel ??= new SelectionModel(true);\n      return this._expansionModel;\n    }\n    return this.treeControl.expansionModel;\n  }\n  /** Set up a subscription for the data provided by the data source. */\n  _subscribeToDataChanges() {\n    if (this._dataSubscription) {\n      return;\n    }\n    let dataStream;\n    if (isDataSource(this._dataSource)) {\n      dataStream = this._dataSource.connect(this);\n    } else if (isObservable(this._dataSource)) {\n      dataStream = this._dataSource;\n    } else if (Array.isArray(this._dataSource)) {\n      dataStream = of(this._dataSource);\n    }\n    if (!dataStream) {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        throw getTreeNoValidDataSourceError();\n      }\n      return;\n    }\n    this._dataSubscription = this._getRenderData(dataStream).pipe(takeUntil(this._onDestroy)).subscribe(renderingData => {\n      this._renderDataChanges(renderingData);\n    });\n  }\n  /** Given an Observable containing a stream of the raw data, returns an Observable containing the RenderingData */\n  _getRenderData(dataStream) {\n    const expansionModel = this._getExpansionModel();\n    return combineLatest([dataStream, this._nodeType,\n    // We don't use the expansion data directly, however we add it here to essentially\n    // trigger data rendering when expansion changes occur.\n    expansionModel.changed.pipe(startWith(null), tap(expansionChanges => {\n      this._emitExpansionChanges(expansionChanges);\n    }))]).pipe(switchMap(([data, nodeType]) => {\n      if (nodeType === null) {\n        return of({\n          renderNodes: data,\n          flattenedNodes: null,\n          nodeType\n        });\n      }\n      // If we're here, then we know what our node type is, and therefore can\n      // perform our usual rendering pipeline, which necessitates converting the data\n      return this._computeRenderingData(data, nodeType).pipe(map(convertedData => ({\n        ...convertedData,\n        nodeType\n      })));\n    }));\n  }\n  _renderDataChanges(data) {\n    if (data.nodeType === null) {\n      this.renderNodeChanges(data.renderNodes);\n      return;\n    }\n    // If we're here, then we know what our node type is, and therefore can\n    // perform our usual rendering pipeline.\n    this._updateCachedData(data.flattenedNodes);\n    this.renderNodeChanges(data.renderNodes);\n    this._updateKeyManagerItems(data.flattenedNodes);\n  }\n  _emitExpansionChanges(expansionChanges) {\n    if (!expansionChanges) {\n      return;\n    }\n    const nodes = this._nodes.value;\n    for (const added of expansionChanges.added) {\n      const node = nodes.get(added);\n      node?._emitExpansionState(true);\n    }\n    for (const removed of expansionChanges.removed) {\n      const node = nodes.get(removed);\n      node?._emitExpansionState(false);\n    }\n  }\n  _initializeKeyManager() {\n    const items = combineLatest([this._keyManagerNodes, this._nodes]).pipe(map(([keyManagerNodes, renderNodes]) => keyManagerNodes.reduce((items, data) => {\n      const node = renderNodes.get(this._getExpansionKey(data));\n      if (node) {\n        items.push(node);\n      }\n      return items;\n    }, [])));\n    const keyManagerOptions = {\n      trackBy: node => this._getExpansionKey(node.data),\n      skipPredicate: node => !!node.isDisabled,\n      typeAheadDebounceInterval: true,\n      horizontalOrientation: this._dir.value\n    };\n    this._keyManager = this._keyManagerFactory(items, keyManagerOptions);\n  }\n  _initializeDataDiffer() {\n    // Provide a default trackBy based on `_getExpansionKey` if one isn't provided.\n    const trackBy = this.trackBy ?? ((_index, item) => this._getExpansionKey(item));\n    this._dataDiffer = this._differs.find([]).create(trackBy);\n  }\n  _checkTreeControlUsage() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      // Verify that Tree follows API contract of using one of TreeControl, levelAccessor or\n      // childrenAccessor. Throw an appropriate error if contract is not met.\n      let numTreeControls = 0;\n      if (this.treeControl) {\n        numTreeControls++;\n      }\n      if (this.levelAccessor) {\n        numTreeControls++;\n      }\n      if (this.childrenAccessor) {\n        numTreeControls++;\n      }\n      if (!numTreeControls) {\n        throw getTreeControlMissingError();\n      } else if (numTreeControls > 1) {\n        throw getMultipleTreeControlsError();\n      }\n    }\n  }\n  /** Check for changes made in the data and render each change (node added/removed/moved). */\n  renderNodeChanges(data, dataDiffer = this._dataDiffer, viewContainer = this._nodeOutlet.viewContainer, parentData) {\n    const changes = dataDiffer.diff(data);\n    // Some tree consumers expect change detection to propagate to nodes\n    // even when the array itself hasn't changed; we explicitly detect changes\n    // anyways in order for nodes to update their data.\n    //\n    // However, if change detection is called while the component's view is\n    // still initing, then the order of child views initing will be incorrect;\n    // to prevent this, we only exit early if the view hasn't initialized yet.\n    if (!changes && !this._viewInit) {\n      return;\n    }\n    changes?.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {\n      if (item.previousIndex == null) {\n        this.insertNode(data[currentIndex], currentIndex, viewContainer, parentData);\n      } else if (currentIndex == null) {\n        viewContainer.remove(adjustedPreviousIndex);\n      } else {\n        const view = viewContainer.get(adjustedPreviousIndex);\n        viewContainer.move(view, currentIndex);\n      }\n    });\n    // If the data itself changes, but keeps the same trackBy, we need to update the templates'\n    // context to reflect the new object.\n    changes?.forEachIdentityChange(record => {\n      const newData = record.item;\n      if (record.currentIndex != undefined) {\n        const view = viewContainer.get(record.currentIndex);\n        view.context.$implicit = newData;\n      }\n    });\n    // Note: we only `detectChanges` from a top-level call, otherwise we risk overflowing\n    // the call stack since this method is called recursively (see #29733.)\n    // TODO: change to `this._changeDetectorRef.markForCheck()`,\n    // or just switch this component to use signals.\n    if (parentData) {\n      this._changeDetectorRef.markForCheck();\n    } else {\n      this._changeDetectorRef.detectChanges();\n    }\n  }\n  /**\n   * Finds the matching node definition that should be used for this node data. If there is only\n   * one node definition, it is returned. Otherwise, find the node definition that has a when\n   * predicate that returns true with the data. If none return true, return the default node\n   * definition.\n   */\n  _getNodeDef(data, i) {\n    if (this._nodeDefs.length === 1) {\n      return this._nodeDefs.first;\n    }\n    const nodeDef = this._nodeDefs.find(def => def.when && def.when(i, data)) || this._defaultNodeDef;\n    if (!nodeDef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getTreeMissingMatchingNodeDefError();\n    }\n    return nodeDef;\n  }\n  /**\n   * Create the embedded view for the data node template and place it in the correct index location\n   * within the data node view container.\n   */\n  insertNode(nodeData, index, viewContainer, parentData) {\n    const levelAccessor = this._getLevelAccessor();\n    const node = this._getNodeDef(nodeData, index);\n    const key = this._getExpansionKey(nodeData);\n    // Node context that will be provided to created embedded view\n    const context = new CdkTreeNodeOutletContext(nodeData);\n    parentData ??= this._parents.get(key) ?? undefined;\n    // If the tree is flat tree, then use the `getLevel` function in flat tree control\n    // Otherwise, use the level of parent node.\n    if (levelAccessor) {\n      context.level = levelAccessor(nodeData);\n    } else if (parentData !== undefined && this._levels.has(this._getExpansionKey(parentData))) {\n      context.level = this._levels.get(this._getExpansionKey(parentData)) + 1;\n    } else {\n      context.level = 0;\n    }\n    this._levels.set(key, context.level);\n    // Use default tree nodeOutlet, or nested node's nodeOutlet\n    const container = viewContainer ? viewContainer : this._nodeOutlet.viewContainer;\n    container.createEmbeddedView(node.template, context, index);\n    // Set the data to just created `CdkTreeNode`.\n    // The `CdkTreeNode` created from `createEmbeddedView` will be saved in static variable\n    //     `mostRecentTreeNode`. We get it from static variable and pass the node data to it.\n    if (CdkTreeNode.mostRecentTreeNode) {\n      CdkTreeNode.mostRecentTreeNode.data = nodeData;\n    }\n  }\n  /** Whether the data node is expanded or collapsed. Returns true if it's expanded. */\n  isExpanded(dataNode) {\n    return !!(this.treeControl?.isExpanded(dataNode) || this._expansionModel?.isSelected(this._getExpansionKey(dataNode)));\n  }\n  /** If the data node is currently expanded, collapse it. Otherwise, expand it. */\n  toggle(dataNode) {\n    if (this.treeControl) {\n      this.treeControl.toggle(dataNode);\n    } else if (this._expansionModel) {\n      this._expansionModel.toggle(this._getExpansionKey(dataNode));\n    }\n  }\n  /** Expand the data node. If it is already expanded, does nothing. */\n  expand(dataNode) {\n    if (this.treeControl) {\n      this.treeControl.expand(dataNode);\n    } else if (this._expansionModel) {\n      this._expansionModel.select(this._getExpansionKey(dataNode));\n    }\n  }\n  /** Collapse the data node. If it is already collapsed, does nothing. */\n  collapse(dataNode) {\n    if (this.treeControl) {\n      this.treeControl.collapse(dataNode);\n    } else if (this._expansionModel) {\n      this._expansionModel.deselect(this._getExpansionKey(dataNode));\n    }\n  }\n  /**\n   * If the data node is currently expanded, collapse it and all its descendants.\n   * Otherwise, expand it and all its descendants.\n   */\n  toggleDescendants(dataNode) {\n    if (this.treeControl) {\n      this.treeControl.toggleDescendants(dataNode);\n    } else if (this._expansionModel) {\n      if (this.isExpanded(dataNode)) {\n        this.collapseDescendants(dataNode);\n      } else {\n        this.expandDescendants(dataNode);\n      }\n    }\n  }\n  /**\n   * Expand the data node and all its descendants. If they are already expanded, does nothing.\n   */\n  expandDescendants(dataNode) {\n    if (this.treeControl) {\n      this.treeControl.expandDescendants(dataNode);\n    } else if (this._expansionModel) {\n      const expansionModel = this._expansionModel;\n      expansionModel.select(this._getExpansionKey(dataNode));\n      this._getDescendants(dataNode).pipe(take(1), takeUntil(this._onDestroy)).subscribe(children => {\n        expansionModel.select(...children.map(child => this._getExpansionKey(child)));\n      });\n    }\n  }\n  /** Collapse the data node and all its descendants. If it is already collapsed, does nothing. */\n  collapseDescendants(dataNode) {\n    if (this.treeControl) {\n      this.treeControl.collapseDescendants(dataNode);\n    } else if (this._expansionModel) {\n      const expansionModel = this._expansionModel;\n      expansionModel.deselect(this._getExpansionKey(dataNode));\n      this._getDescendants(dataNode).pipe(take(1), takeUntil(this._onDestroy)).subscribe(children => {\n        expansionModel.deselect(...children.map(child => this._getExpansionKey(child)));\n      });\n    }\n  }\n  /** Expands all data nodes in the tree. */\n  expandAll() {\n    if (this.treeControl) {\n      this.treeControl.expandAll();\n    } else if (this._expansionModel) {\n      const expansionModel = this._expansionModel;\n      expansionModel.select(...this._flattenedNodes.value.map(child => this._getExpansionKey(child)));\n    }\n  }\n  /** Collapse all data nodes in the tree. */\n  collapseAll() {\n    if (this.treeControl) {\n      this.treeControl.collapseAll();\n    } else if (this._expansionModel) {\n      const expansionModel = this._expansionModel;\n      expansionModel.deselect(...this._flattenedNodes.value.map(child => this._getExpansionKey(child)));\n    }\n  }\n  /** Level accessor, used for compatibility between the old Tree and new Tree */\n  _getLevelAccessor() {\n    return this.treeControl?.getLevel?.bind(this.treeControl) ?? this.levelAccessor;\n  }\n  /** Children accessor, used for compatibility between the old Tree and new Tree */\n  _getChildrenAccessor() {\n    return this.treeControl?.getChildren?.bind(this.treeControl) ?? this.childrenAccessor;\n  }\n  /**\n   * Gets the direct children of a node; used for compatibility between the old tree and the\n   * new tree.\n   */\n  _getDirectChildren(dataNode) {\n    const levelAccessor = this._getLevelAccessor();\n    const expansionModel = this._expansionModel ?? this.treeControl?.expansionModel;\n    if (!expansionModel) {\n      return of([]);\n    }\n    const key = this._getExpansionKey(dataNode);\n    const isExpanded = expansionModel.changed.pipe(switchMap(changes => {\n      if (changes.added.includes(key)) {\n        return of(true);\n      } else if (changes.removed.includes(key)) {\n        return of(false);\n      }\n      return EMPTY;\n    }), startWith(this.isExpanded(dataNode)));\n    if (levelAccessor) {\n      return combineLatest([isExpanded, this._flattenedNodes]).pipe(map(([expanded, flattenedNodes]) => {\n        if (!expanded) {\n          return [];\n        }\n        return this._findChildrenByLevel(levelAccessor, flattenedNodes, dataNode, 1);\n      }));\n    }\n    const childrenAccessor = this._getChildrenAccessor();\n    if (childrenAccessor) {\n      return coerceObservable(childrenAccessor(dataNode) ?? []);\n    }\n    throw getTreeControlMissingError();\n  }\n  /**\n   * Given the list of flattened nodes, the level accessor, and the level range within\n   * which to consider children, finds the children for a given node.\n   *\n   * For example, for direct children, `levelDelta` would be 1. For all descendants,\n   * `levelDelta` would be Infinity.\n   */\n  _findChildrenByLevel(levelAccessor, flattenedNodes, dataNode, levelDelta) {\n    const key = this._getExpansionKey(dataNode);\n    const startIndex = flattenedNodes.findIndex(node => this._getExpansionKey(node) === key);\n    const dataNodeLevel = levelAccessor(dataNode);\n    const expectedLevel = dataNodeLevel + levelDelta;\n    const results = [];\n    // Goes through flattened tree nodes in the `flattenedNodes` array, and get all\n    // descendants within a certain level range.\n    //\n    // If we reach a node whose level is equal to or less than the level of the tree node,\n    // we hit a sibling or parent's sibling, and should stop.\n    for (let i = startIndex + 1; i < flattenedNodes.length; i++) {\n      const currentLevel = levelAccessor(flattenedNodes[i]);\n      if (currentLevel <= dataNodeLevel) {\n        break;\n      }\n      if (currentLevel <= expectedLevel) {\n        results.push(flattenedNodes[i]);\n      }\n    }\n    return results;\n  }\n  /**\n   * Adds the specified node component to the tree's internal registry.\n   *\n   * This primarily facilitates keyboard navigation.\n   */\n  _registerNode(node) {\n    this._nodes.value.set(this._getExpansionKey(node.data), node);\n    this._nodes.next(this._nodes.value);\n  }\n  /** Removes the specified node component from the tree's internal registry. */\n  _unregisterNode(node) {\n    this._nodes.value.delete(this._getExpansionKey(node.data));\n    this._nodes.next(this._nodes.value);\n  }\n  /**\n   * For the given node, determine the level where this node appears in the tree.\n   *\n   * This is intended to be used for `aria-level` but is 0-indexed.\n   */\n  _getLevel(node) {\n    return this._levels.get(this._getExpansionKey(node));\n  }\n  /**\n   * For the given node, determine the size of the parent's child set.\n   *\n   * This is intended to be used for `aria-setsize`.\n   */\n  _getSetSize(dataNode) {\n    const set = this._getAriaSet(dataNode);\n    return set.length;\n  }\n  /**\n   * For the given node, determine the index (starting from 1) of the node in its parent's child set.\n   *\n   * This is intended to be used for `aria-posinset`.\n   */\n  _getPositionInSet(dataNode) {\n    const set = this._getAriaSet(dataNode);\n    const key = this._getExpansionKey(dataNode);\n    return set.findIndex(node => this._getExpansionKey(node) === key) + 1;\n  }\n  /** Given a CdkTreeNode, gets the node that renders that node's parent's data. */\n  _getNodeParent(node) {\n    const parent = this._parents.get(this._getExpansionKey(node.data));\n    return parent && this._nodes.value.get(this._getExpansionKey(parent));\n  }\n  /** Given a CdkTreeNode, gets the nodes that renders that node's child data. */\n  _getNodeChildren(node) {\n    return this._getDirectChildren(node.data).pipe(map(children => children.reduce((nodes, child) => {\n      const value = this._nodes.value.get(this._getExpansionKey(child));\n      if (value) {\n        nodes.push(value);\n      }\n      return nodes;\n    }, [])));\n  }\n  /** `keydown` event handler; this just passes the event to the `TreeKeyManager`. */\n  _sendKeydownToKeyManager(event) {\n    this._keyManager.onKeydown(event);\n  }\n  /** Gets all nested descendants of a given node. */\n  _getDescendants(dataNode) {\n    if (this.treeControl) {\n      return of(this.treeControl.getDescendants(dataNode));\n    }\n    if (this.levelAccessor) {\n      const results = this._findChildrenByLevel(this.levelAccessor, this._flattenedNodes.value, dataNode, Infinity);\n      return of(results);\n    }\n    if (this.childrenAccessor) {\n      return this._getAllChildrenRecursively(dataNode).pipe(reduce((allChildren, nextChildren) => {\n        allChildren.push(...nextChildren);\n        return allChildren;\n      }, []));\n    }\n    throw getTreeControlMissingError();\n  }\n  /**\n   * Gets all children and sub-children of the provided node.\n   *\n   * This will emit multiple times, in the order that the children will appear\n   * in the tree, and can be combined with a `reduce` operator.\n   */\n  _getAllChildrenRecursively(dataNode) {\n    if (!this.childrenAccessor) {\n      return of([]);\n    }\n    return coerceObservable(this.childrenAccessor(dataNode)).pipe(take(1), switchMap(children => {\n      // Here, we cache the parents of a particular child so that we can compute the levels.\n      for (const child of children) {\n        this._parents.set(this._getExpansionKey(child), dataNode);\n      }\n      return of(...children).pipe(concatMap(child => concat(of([child]), this._getAllChildrenRecursively(child))));\n    }));\n  }\n  _getExpansionKey(dataNode) {\n    // In the case that a key accessor function was not provided by the\n    // tree user, we'll default to using the node object itself as the key.\n    //\n    // This cast is safe since:\n    // - if an expansionKey is provided, TS will infer the type of K to be\n    //   the return type.\n    // - if it's not, then K will be defaulted to T.\n    return this.expansionKey?.(dataNode) ?? dataNode;\n  }\n  _getAriaSet(node) {\n    const key = this._getExpansionKey(node);\n    const parent = this._parents.get(key);\n    const parentKey = parent ? this._getExpansionKey(parent) : null;\n    const set = this._ariaSets.get(parentKey);\n    return set ?? [node];\n  }\n  /**\n   * Finds the parent for the given node. If this is a root node, this\n   * returns null. If we're unable to determine the parent, for example,\n   * if we don't have cached node data, this returns undefined.\n   */\n  _findParentForNode(node, index, cachedNodes) {\n    // In all cases, we have a mapping from node to level; all we need to do here is backtrack in\n    // our flattened list of nodes to determine the first node that's of a level lower than the\n    // provided node.\n    if (!cachedNodes.length) {\n      return null;\n    }\n    const currentLevel = this._levels.get(this._getExpansionKey(node)) ?? 0;\n    for (let parentIndex = index - 1; parentIndex >= 0; parentIndex--) {\n      const parentNode = cachedNodes[parentIndex];\n      const parentLevel = this._levels.get(this._getExpansionKey(parentNode)) ?? 0;\n      if (parentLevel < currentLevel) {\n        return parentNode;\n      }\n    }\n    return null;\n  }\n  /**\n   * Given a set of root nodes and the current node level, flattens any nested\n   * nodes into a single array.\n   *\n   * If any nodes are not expanded, then their children will not be added into the array.\n   * This will still traverse all nested children in order to build up our internal data\n   * models, but will not include them in the returned array.\n   */\n  _flattenNestedNodesWithExpansion(nodes, level = 0) {\n    const childrenAccessor = this._getChildrenAccessor();\n    // If we're using a level accessor, we don't need to flatten anything.\n    if (!childrenAccessor) {\n      return of([...nodes]);\n    }\n    return of(...nodes).pipe(concatMap(node => {\n      const parentKey = this._getExpansionKey(node);\n      if (!this._parents.has(parentKey)) {\n        this._parents.set(parentKey, null);\n      }\n      this._levels.set(parentKey, level);\n      const children = coerceObservable(childrenAccessor(node));\n      return concat(of([node]), children.pipe(take(1), tap(childNodes => {\n        this._ariaSets.set(parentKey, [...(childNodes ?? [])]);\n        for (const child of childNodes ?? []) {\n          const childKey = this._getExpansionKey(child);\n          this._parents.set(childKey, node);\n          this._levels.set(childKey, level + 1);\n        }\n      }), switchMap(childNodes => {\n        if (!childNodes) {\n          return of([]);\n        }\n        return this._flattenNestedNodesWithExpansion(childNodes, level + 1).pipe(map(nestedNodes => this.isExpanded(node) ? nestedNodes : []));\n      })));\n    }), reduce((results, children) => {\n      results.push(...children);\n      return results;\n    }, []));\n  }\n  /**\n   * Converts children for certain tree configurations.\n   *\n   * This also computes parent, level, and group data.\n   */\n  _computeRenderingData(nodes, nodeType) {\n    // The only situations where we have to convert children types is when\n    // they're mismatched; i.e. if the tree is using a childrenAccessor and the\n    // nodes are flat, or if the tree is using a levelAccessor and the nodes are\n    // nested.\n    if (this.childrenAccessor && nodeType === 'flat') {\n      // This flattens children into a single array.\n      this._ariaSets.set(null, [...nodes]);\n      return this._flattenNestedNodesWithExpansion(nodes).pipe(map(flattenedNodes => ({\n        renderNodes: flattenedNodes,\n        flattenedNodes\n      })));\n    } else if (this.levelAccessor && nodeType === 'nested') {\n      // In the nested case, we only look for root nodes. The CdkNestedNode\n      // itself will handle rendering each individual node's children.\n      const levelAccessor = this.levelAccessor;\n      return of(nodes.filter(node => levelAccessor(node) === 0)).pipe(map(rootNodes => ({\n        renderNodes: rootNodes,\n        flattenedNodes: nodes\n      })), tap(({\n        flattenedNodes\n      }) => {\n        this._calculateParents(flattenedNodes);\n      }));\n    } else if (nodeType === 'flat') {\n      // In the case of a TreeControl, we know that the node type matches up\n      // with the TreeControl, and so no conversions are necessary. Otherwise,\n      // we've already confirmed that the data model matches up with the\n      // desired node type here.\n      return of({\n        renderNodes: nodes,\n        flattenedNodes: nodes\n      }).pipe(tap(({\n        flattenedNodes\n      }) => {\n        this._calculateParents(flattenedNodes);\n      }));\n    } else {\n      // For nested nodes, we still need to perform the node flattening in order\n      // to maintain our caches for various tree operations.\n      this._ariaSets.set(null, [...nodes]);\n      return this._flattenNestedNodesWithExpansion(nodes).pipe(map(flattenedNodes => ({\n        renderNodes: nodes,\n        flattenedNodes\n      })));\n    }\n  }\n  _updateCachedData(flattenedNodes) {\n    this._flattenedNodes.next(flattenedNodes);\n  }\n  _updateKeyManagerItems(flattenedNodes) {\n    this._keyManagerNodes.next(flattenedNodes);\n  }\n  /** Traverse the flattened node data and compute parents, levels, and group data. */\n  _calculateParents(flattenedNodes) {\n    const levelAccessor = this._getLevelAccessor();\n    if (!levelAccessor) {\n      return;\n    }\n    this._parents.clear();\n    this._ariaSets.clear();\n    for (let index = 0; index < flattenedNodes.length; index++) {\n      const dataNode = flattenedNodes[index];\n      const key = this._getExpansionKey(dataNode);\n      this._levels.set(key, levelAccessor(dataNode));\n      const parent = this._findParentForNode(dataNode, index, flattenedNodes);\n      this._parents.set(key, parent);\n      const parentKey = parent ? this._getExpansionKey(parent) : null;\n      const group = this._ariaSets.get(parentKey) ?? [];\n      group.splice(index, 0, dataNode);\n      this._ariaSets.set(parentKey, group);\n    }\n  }\n  static {\n    this.ɵfac = function CdkTree_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTree)(i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n    };\n  }\n  static {\n    this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: CdkTree,\n      selectors: [[\"cdk-tree\"]],\n      contentQueries: function CdkTree_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, CdkTreeNodeDef, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._nodeDefs = _t);\n        }\n      },\n      viewQuery: function CdkTree_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(CdkTreeNodeOutlet, 7);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._nodeOutlet = _t.first);\n        }\n      },\n      hostAttrs: [\"role\", \"tree\", 1, \"cdk-tree\"],\n      hostBindings: function CdkTree_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"keydown\", function CdkTree_keydown_HostBindingHandler($event) {\n            return ctx._sendKeydownToKeyManager($event);\n          });\n        }\n      },\n      inputs: {\n        dataSource: \"dataSource\",\n        treeControl: \"treeControl\",\n        levelAccessor: \"levelAccessor\",\n        childrenAccessor: \"childrenAccessor\",\n        trackBy: \"trackBy\",\n        expansionKey: \"expansionKey\"\n      },\n      exportAs: [\"cdkTree\"],\n      standalone: true,\n      features: [i0.ɵɵStandaloneFeature],\n      decls: 1,\n      vars: 0,\n      consts: [[\"cdkTreeNodeOutlet\", \"\"]],\n      template: function CdkTree_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementContainer(0, 0);\n        }\n      },\n      dependencies: [CdkTreeNodeOutlet],\n      encapsulation: 2\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkTree, [{\n    type: Component,\n    args: [{\n      selector: 'cdk-tree',\n      exportAs: 'cdkTree',\n      template: `<ng-container cdkTreeNodeOutlet></ng-container>`,\n      host: {\n        'class': 'cdk-tree',\n        'role': 'tree',\n        '(keydown)': '_sendKeydownToKeyManager($event)'\n      },\n      encapsulation: ViewEncapsulation.None,\n      // The \"OnPush\" status for the `CdkTree` component is effectively a noop, so we are removing it.\n      // The view for `CdkTree` consists entirely of templates declared in other views. As they are\n      // declared elsewhere, they are checked when their declaration points are checked.\n      // tslint:disable-next-line:validate-decorators\n      changeDetection: ChangeDetectionStrategy.Default,\n      standalone: true,\n      imports: [CdkTreeNodeOutlet]\n    }]\n  }], () => [{\n    type: i0.IterableDiffers\n  }, {\n    type: i0.ChangeDetectorRef\n  }], {\n    dataSource: [{\n      type: Input\n    }],\n    treeControl: [{\n      type: Input\n    }],\n    levelAccessor: [{\n      type: Input\n    }],\n    childrenAccessor: [{\n      type: Input\n    }],\n    trackBy: [{\n      type: Input\n    }],\n    expansionKey: [{\n      type: Input\n    }],\n    _nodeOutlet: [{\n      type: ViewChild,\n      args: [CdkTreeNodeOutlet, {\n        static: true\n      }]\n    }],\n    _nodeDefs: [{\n      type: ContentChildren,\n      args: [CdkTreeNodeDef, {\n        // We need to use `descendants: true`, because Ivy will no longer match\n        // indirect descendants if it's left as false.\n        descendants: true\n      }]\n    }]\n  });\n})();\n/**\n * Tree node for CdkTree. It contains the data in the tree node.\n */\nclass CdkTreeNode {\n  /**\n   * The role of the tree node.\n   *\n   * @deprecated This will be ignored; the tree will automatically determine the appropriate role\n   * for tree node. This input will be removed in a future version.\n   * @breaking-change 21.0.0\n   */\n  get role() {\n    return 'treeitem';\n  }\n  set role(_role) {\n    // ignore any role setting, we handle this internally.\n  }\n  /**\n   * Whether or not this node is expandable.\n   *\n   * If not using `FlatTreeControl`, or if `isExpandable` is not provided to\n   * `NestedTreeControl`, this should be provided for correct node a11y.\n   */\n  get isExpandable() {\n    return this._isExpandable();\n  }\n  set isExpandable(isExpandable) {\n    this._inputIsExpandable = isExpandable;\n    if (this.data && !this._isExpandable || !this._inputIsExpandable) {\n      return;\n    }\n    // If the node is being set to expandable, ensure that the status of the\n    // node is propagated\n    if (this._inputIsExpanded) {\n      this.expand();\n    } else if (this._inputIsExpanded === false) {\n      this.collapse();\n    }\n  }\n  get isExpanded() {\n    return this._tree.isExpanded(this._data);\n  }\n  set isExpanded(isExpanded) {\n    this._inputIsExpanded = isExpanded;\n    if (isExpanded) {\n      this.expand();\n    } else {\n      this.collapse();\n    }\n  }\n  getLabel() {\n    return this.typeaheadLabel || this._elementRef.nativeElement.textContent?.trim() || '';\n  }\n  /**\n   * The most recently created `CdkTreeNode`. We save it in static variable so we can retrieve it\n   * in `CdkTree` and set the data to it.\n   */\n  static {\n    this.mostRecentTreeNode = null;\n  }\n  /** The tree node's data. */\n  get data() {\n    return this._data;\n  }\n  set data(value) {\n    if (value !== this._data) {\n      this._data = value;\n      this._dataChanges.next();\n    }\n  }\n  /* If leaf node, return true to not assign aria-expanded attribute */\n  get isLeafNode() {\n    // If flat tree node data returns false for expandable property, it's a leaf node\n    if (this._tree.treeControl?.isExpandable !== undefined && !this._tree.treeControl.isExpandable(this._data)) {\n      return true;\n      // If nested tree node data returns 0 descendants, it's a leaf node\n    } else if (this._tree.treeControl?.isExpandable === undefined && this._tree.treeControl?.getDescendants(this._data).length === 0) {\n      return true;\n    }\n    return false;\n  }\n  get level() {\n    // If the tree has a levelAccessor, use it to get the level. Otherwise read the\n    // aria-level off the parent node and use it as the level for this node (note aria-level is\n    // 1-indexed, while this property is 0-indexed, so we don't need to increment).\n    return this._tree._getLevel(this._data) ?? this._parentNodeAriaLevel;\n  }\n  /** Determines if the tree node is expandable. */\n  _isExpandable() {\n    if (this._tree.treeControl) {\n      if (this.isLeafNode) {\n        return false;\n      }\n      // For compatibility with trees created using TreeControl before we added\n      // CdkTreeNode#isExpandable.\n      return true;\n    }\n    return this._inputIsExpandable;\n  }\n  /**\n   * Determines the value for `aria-expanded`.\n   *\n   * For non-expandable nodes, this is `null`.\n   */\n  _getAriaExpanded() {\n    if (!this._isExpandable()) {\n      return null;\n    }\n    return String(this.isExpanded);\n  }\n  /**\n   * Determines the size of this node's parent's child set.\n   *\n   * This is intended to be used for `aria-setsize`.\n   */\n  _getSetSize() {\n    return this._tree._getSetSize(this._data);\n  }\n  /**\n   * Determines the index (starting from 1) of this node in its parent's child set.\n   *\n   * This is intended to be used for `aria-posinset`.\n   */\n  _getPositionInSet() {\n    return this._tree._getPositionInSet(this._data);\n  }\n  constructor(_elementRef, _tree) {\n    this._elementRef = _elementRef;\n    this._tree = _tree;\n    this._tabindex = -1;\n    /** This emits when the node has been programatically activated or activated by keyboard. */\n    this.activation = new EventEmitter();\n    /** This emits when the node's expansion status has been changed. */\n    this.expandedChange = new EventEmitter();\n    /** Subject that emits when the component has been destroyed. */\n    this._destroyed = new Subject();\n    /** Emits when the node's data has changed. */\n    this._dataChanges = new Subject();\n    this._inputIsExpandable = false;\n    this._inputIsExpanded = undefined;\n    /**\n     * Flag used to determine whether or not we should be focusing the actual element based on\n     * some user interaction (click or focus). On click, we don't forcibly focus the element\n     * since the click could trigger some other component that wants to grab its own focus\n     * (e.g. menu, dialog).\n     */\n    this._shouldFocus = true;\n    this._changeDetectorRef = inject(ChangeDetectorRef);\n    CdkTreeNode.mostRecentTreeNode = this;\n  }\n  ngOnInit() {\n    this._parentNodeAriaLevel = getParentNodeAriaLevel(this._elementRef.nativeElement);\n    this._tree._getExpansionModel().changed.pipe(map(() => this.isExpanded), distinctUntilChanged()).subscribe(() => {\n      this._changeDetectorRef.markForCheck();\n    });\n    this._tree._setNodeTypeIfUnset('flat');\n    this._tree._registerNode(this);\n  }\n  ngOnDestroy() {\n    // If this is the last tree node being destroyed,\n    // clear out the reference to avoid leaking memory.\n    if (CdkTreeNode.mostRecentTreeNode === this) {\n      CdkTreeNode.mostRecentTreeNode = null;\n    }\n    this._dataChanges.complete();\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n  getParent() {\n    return this._tree._getNodeParent(this) ?? null;\n  }\n  getChildren() {\n    return this._tree._getNodeChildren(this);\n  }\n  /** Focuses this data node. Implemented for TreeKeyManagerItem. */\n  focus() {\n    this._tabindex = 0;\n    if (this._shouldFocus) {\n      this._elementRef.nativeElement.focus();\n    }\n    this._changeDetectorRef.markForCheck();\n  }\n  /** Defocus this data node. */\n  unfocus() {\n    this._tabindex = -1;\n    this._changeDetectorRef.markForCheck();\n  }\n  /** Emits an activation event. Implemented for TreeKeyManagerItem. */\n  activate() {\n    if (this.isDisabled) {\n      return;\n    }\n    this.activation.next(this._data);\n  }\n  /** Collapses this data node. Implemented for TreeKeyManagerItem. */\n  collapse() {\n    if (this.isExpandable) {\n      this._tree.collapse(this._data);\n    }\n  }\n  /** Expands this data node. Implemented for TreeKeyManagerItem. */\n  expand() {\n    if (this.isExpandable) {\n      this._tree.expand(this._data);\n    }\n  }\n  /** Makes the node focusable. Implemented for TreeKeyManagerItem. */\n  makeFocusable() {\n    this._tabindex = 0;\n    this._changeDetectorRef.markForCheck();\n  }\n  _focusItem() {\n    if (this.isDisabled) {\n      return;\n    }\n    this._tree._keyManager.focusItem(this);\n  }\n  _setActiveItem() {\n    if (this.isDisabled) {\n      return;\n    }\n    this._shouldFocus = false;\n    this._tree._keyManager.focusItem(this);\n    this._shouldFocus = true;\n  }\n  _emitExpansionState(expanded) {\n    this.expandedChange.emit(expanded);\n  }\n  static {\n    this.ɵfac = function CdkTreeNode_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNode)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(CdkTree));\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkTreeNode,\n      selectors: [[\"cdk-tree-node\"]],\n      hostAttrs: [\"role\", \"treeitem\", 1, \"cdk-tree-node\"],\n      hostVars: 5,\n      hostBindings: function CdkTreeNode_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function CdkTreeNode_click_HostBindingHandler() {\n            return ctx._setActiveItem();\n          })(\"focus\", function CdkTreeNode_focus_HostBindingHandler() {\n            return ctx._focusItem();\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"tabindex\", ctx._tabindex);\n          i0.ɵɵattribute(\"aria-expanded\", ctx._getAriaExpanded())(\"aria-level\", ctx.level + 1)(\"aria-posinset\", ctx._getPositionInSet())(\"aria-setsize\", ctx._getSetSize());\n        }\n      },\n      inputs: {\n        role: \"role\",\n        isExpandable: [2, \"isExpandable\", \"isExpandable\", booleanAttribute],\n        isExpanded: \"isExpanded\",\n        isDisabled: [2, \"isDisabled\", \"isDisabled\", booleanAttribute],\n        typeaheadLabel: [0, \"cdkTreeNodeTypeaheadLabel\", \"typeaheadLabel\"]\n      },\n      outputs: {\n        activation: \"activation\",\n        expandedChange: \"expandedChange\"\n      },\n      exportAs: [\"cdkTreeNode\"],\n      standalone: true,\n      features: [i0.ɵɵInputTransformsFeature]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkTreeNode, [{\n    type: Directive,\n    args: [{\n      selector: 'cdk-tree-node',\n      exportAs: 'cdkTreeNode',\n      host: {\n        'class': 'cdk-tree-node',\n        '[attr.aria-expanded]': '_getAriaExpanded()',\n        '[attr.aria-level]': 'level + 1',\n        '[attr.aria-posinset]': '_getPositionInSet()',\n        '[attr.aria-setsize]': '_getSetSize()',\n        '[tabindex]': '_tabindex',\n        'role': 'treeitem',\n        '(click)': '_setActiveItem()',\n        '(focus)': '_focusItem()'\n      },\n      standalone: true\n    }]\n  }], () => [{\n    type: i0.ElementRef\n  }, {\n    type: CdkTree\n  }], {\n    role: [{\n      type: Input\n    }],\n    isExpandable: [{\n      type: Input,\n      args: [{\n        transform: booleanAttribute\n      }]\n    }],\n    isExpanded: [{\n      type: Input\n    }],\n    isDisabled: [{\n      type: Input,\n      args: [{\n        transform: booleanAttribute\n      }]\n    }],\n    typeaheadLabel: [{\n      type: Input,\n      args: ['cdkTreeNodeTypeaheadLabel']\n    }],\n    activation: [{\n      type: Output\n    }],\n    expandedChange: [{\n      type: Output\n    }]\n  });\n})();\nfunction getParentNodeAriaLevel(nodeElement) {\n  let parent = nodeElement.parentElement;\n  while (parent && !isNodeElement(parent)) {\n    parent = parent.parentElement;\n  }\n  if (!parent) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      throw Error('Incorrect tree structure containing detached node.');\n    } else {\n      return -1;\n    }\n  } else if (parent.classList.contains('cdk-nested-tree-node')) {\n    return numberAttribute(parent.getAttribute('aria-level'));\n  } else {\n    // The ancestor element is the cdk-tree itself\n    return 0;\n  }\n}\nfunction isNodeElement(element) {\n  const classList = element.classList;\n  return !!(classList?.contains('cdk-nested-tree-node') || classList?.contains('cdk-tree'));\n}\n\n/**\n * Nested node is a child of `<cdk-tree>`. It works with nested tree.\n * By using `cdk-nested-tree-node` component in tree node template, children of the parent node will\n * be added in the `cdkTreeNodeOutlet` in tree node template.\n * The children of node will be automatically added to `cdkTreeNodeOutlet`.\n */\nclass CdkNestedTreeNode extends CdkTreeNode {\n  constructor(elementRef, tree, _differs) {\n    super(elementRef, tree);\n    this._differs = _differs;\n  }\n  ngAfterContentInit() {\n    this._dataDiffer = this._differs.find([]).create(this._tree.trackBy);\n    this._tree._getDirectChildren(this.data).pipe(takeUntil(this._destroyed)).subscribe(result => this.updateChildrenNodes(result));\n    this.nodeOutlet.changes.pipe(takeUntil(this._destroyed)).subscribe(() => this.updateChildrenNodes());\n  }\n  // This is a workaround for https://github.com/angular/angular/issues/23091\n  // In aot mode, the lifecycle hooks from parent class are not called.\n  ngOnInit() {\n    this._tree._setNodeTypeIfUnset('nested');\n    super.ngOnInit();\n  }\n  ngOnDestroy() {\n    this._clear();\n    super.ngOnDestroy();\n  }\n  /** Add children dataNodes to the NodeOutlet */\n  updateChildrenNodes(children) {\n    const outlet = this._getNodeOutlet();\n    if (children) {\n      this._children = children;\n    }\n    if (outlet && this._children) {\n      const viewContainer = outlet.viewContainer;\n      this._tree.renderNodeChanges(this._children, this._dataDiffer, viewContainer, this._data);\n    } else {\n      // Reset the data differ if there's no children nodes displayed\n      this._dataDiffer.diff([]);\n    }\n  }\n  /** Clear the children dataNodes. */\n  _clear() {\n    const outlet = this._getNodeOutlet();\n    if (outlet) {\n      outlet.viewContainer.clear();\n      this._dataDiffer.diff([]);\n    }\n  }\n  /** Gets the outlet for the current node. */\n  _getNodeOutlet() {\n    const outlets = this.nodeOutlet;\n    // Note that since we use `descendants: true` on the query, we have to ensure\n    // that we don't pick up the outlet of a child node by accident.\n    return outlets && outlets.find(outlet => !outlet._node || outlet._node === this);\n  }\n  static {\n    this.ɵfac = function CdkNestedTreeNode_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkNestedTreeNode)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(CdkTree), i0.ɵɵdirectiveInject(i0.IterableDiffers));\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkNestedTreeNode,\n      selectors: [[\"cdk-nested-tree-node\"]],\n      contentQueries: function CdkNestedTreeNode_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, CdkTreeNodeOutlet, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nodeOutlet = _t);\n        }\n      },\n      hostAttrs: [1, \"cdk-nested-tree-node\"],\n      exportAs: [\"cdkNestedTreeNode\"],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CdkTreeNode,\n        useExisting: CdkNestedTreeNode\n      }, {\n        provide: CDK_TREE_NODE_OUTLET_NODE,\n        useExisting: CdkNestedTreeNode\n      }]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkNestedTreeNode, [{\n    type: Directive,\n    args: [{\n      selector: 'cdk-nested-tree-node',\n      exportAs: 'cdkNestedTreeNode',\n      providers: [{\n        provide: CdkTreeNode,\n        useExisting: CdkNestedTreeNode\n      }, {\n        provide: CDK_TREE_NODE_OUTLET_NODE,\n        useExisting: CdkNestedTreeNode\n      }],\n      host: {\n        'class': 'cdk-nested-tree-node'\n      },\n      standalone: true\n    }]\n  }], () => [{\n    type: i0.ElementRef\n  }, {\n    type: CdkTree\n  }, {\n    type: i0.IterableDiffers\n  }], {\n    nodeOutlet: [{\n      type: ContentChildren,\n      args: [CdkTreeNodeOutlet, {\n        // We need to use `descendants: true`, because Ivy will no longer match\n        // indirect descendants if it's left as false.\n        descendants: true\n      }]\n    }]\n  });\n})();\n\n/** Regex used to split a string on its CSS units. */\nconst cssUnitPattern = /([A-Za-z%]+)$/;\n/**\n * Indent for the children tree dataNodes.\n * This directive will add left-padding to the node to show hierarchy.\n */\nclass CdkTreeNodePadding {\n  /** The level of depth of the tree node. The padding will be `level * indent` pixels. */\n  get level() {\n    return this._level;\n  }\n  set level(value) {\n    this._setLevelInput(value);\n  }\n  /**\n   * The indent for each level. Can be a number or a CSS string.\n   * Default number 40px from material design menu sub-menu spec.\n   */\n  get indent() {\n    return this._indent;\n  }\n  set indent(indent) {\n    this._setIndentInput(indent);\n  }\n  constructor(_treeNode, _tree, _element, _dir) {\n    this._treeNode = _treeNode;\n    this._tree = _tree;\n    this._element = _element;\n    this._dir = _dir;\n    /** Subject that emits when the component has been destroyed. */\n    this._destroyed = new Subject();\n    /** CSS units used for the indentation value. */\n    this.indentUnits = 'px';\n    this._indent = 40;\n    this._setPadding();\n    if (_dir) {\n      _dir.change.pipe(takeUntil(this._destroyed)).subscribe(() => this._setPadding(true));\n    }\n    // In Ivy the indentation binding might be set before the tree node's data has been added,\n    // which means that we'll miss the first render. We have to subscribe to changes in the\n    // data to ensure that everything is up to date.\n    _treeNode._dataChanges.subscribe(() => this._setPadding());\n  }\n  ngOnDestroy() {\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n  /** The padding indent value for the tree node. Returns a string with px numbers if not null. */\n  _paddingIndent() {\n    const nodeLevel = (this._treeNode.data && this._tree._getLevel(this._treeNode.data)) ?? null;\n    const level = this._level == null ? nodeLevel : this._level;\n    return typeof level === 'number' ? `${level * this._indent}${this.indentUnits}` : null;\n  }\n  _setPadding(forceChange = false) {\n    const padding = this._paddingIndent();\n    if (padding !== this._currentPadding || forceChange) {\n      const element = this._element.nativeElement;\n      const paddingProp = this._dir && this._dir.value === 'rtl' ? 'paddingRight' : 'paddingLeft';\n      const resetProp = paddingProp === 'paddingLeft' ? 'paddingRight' : 'paddingLeft';\n      element.style[paddingProp] = padding || '';\n      element.style[resetProp] = '';\n      this._currentPadding = padding;\n    }\n  }\n  /**\n   * This has been extracted to a util because of TS 4 and VE.\n   * View Engine doesn't support property rename inheritance.\n   * TS 4.0 doesn't allow properties to override accessors or vice-versa.\n   * @docs-private\n   */\n  _setLevelInput(value) {\n    // Set to null as the fallback value so that _setPadding can fall back to the node level if the\n    // consumer set the directive as `cdkTreeNodePadding=\"\"`. We still want to take this value if\n    // they set 0 explicitly.\n    this._level = isNaN(value) ? null : value;\n    this._setPadding();\n  }\n  /**\n   * This has been extracted to a util because of TS 4 and VE.\n   * View Engine doesn't support property rename inheritance.\n   * TS 4.0 doesn't allow properties to override accessors or vice-versa.\n   * @docs-private\n   */\n  _setIndentInput(indent) {\n    let value = indent;\n    let units = 'px';\n    if (typeof indent === 'string') {\n      const parts = indent.split(cssUnitPattern);\n      value = parts[0];\n      units = parts[1] || units;\n    }\n    this.indentUnits = units;\n    this._indent = numberAttribute(value);\n    this._setPadding();\n  }\n  static {\n    this.ɵfac = function CdkTreeNodePadding_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNodePadding)(i0.ɵɵdirectiveInject(CdkTreeNode), i0.ɵɵdirectiveInject(CdkTree), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i2.Directionality, 8));\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkTreeNodePadding,\n      selectors: [[\"\", \"cdkTreeNodePadding\", \"\"]],\n      inputs: {\n        level: [2, \"cdkTreeNodePadding\", \"level\", numberAttribute],\n        indent: [0, \"cdkTreeNodePaddingIndent\", \"indent\"]\n      },\n      standalone: true,\n      features: [i0.ɵɵInputTransformsFeature]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkTreeNodePadding, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkTreeNodePadding]',\n      standalone: true\n    }]\n  }], () => [{\n    type: CdkTreeNode\n  }, {\n    type: CdkTree\n  }, {\n    type: i0.ElementRef\n  }, {\n    type: i2.Directionality,\n    decorators: [{\n      type: Optional\n    }]\n  }], {\n    level: [{\n      type: Input,\n      args: [{\n        alias: 'cdkTreeNodePadding',\n        transform: numberAttribute\n      }]\n    }],\n    indent: [{\n      type: Input,\n      args: ['cdkTreeNodePaddingIndent']\n    }]\n  });\n})();\n\n/**\n * Node toggle to expand and collapse the node.\n */\nclass CdkTreeNodeToggle {\n  constructor(_tree, _treeNode) {\n    this._tree = _tree;\n    this._treeNode = _treeNode;\n    /** Whether expand/collapse the node recursively. */\n    this.recursive = false;\n  }\n  // Toggle the expanded or collapsed state of this node.\n  //\n  // Focus this node with expanding or collapsing it. This ensures that the active node will always\n  // be visible when expanding and collapsing.\n  _toggle() {\n    this.recursive ? this._tree.toggleDescendants(this._treeNode.data) : this._tree.toggle(this._treeNode.data);\n    this._tree._keyManager.focusItem(this._treeNode);\n  }\n  static {\n    this.ɵfac = function CdkTreeNodeToggle_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNodeToggle)(i0.ɵɵdirectiveInject(CdkTree), i0.ɵɵdirectiveInject(CdkTreeNode));\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkTreeNodeToggle,\n      selectors: [[\"\", \"cdkTreeNodeToggle\", \"\"]],\n      hostAttrs: [\"tabindex\", \"-1\"],\n      hostBindings: function CdkTreeNodeToggle_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function CdkTreeNodeToggle_click_HostBindingHandler($event) {\n            ctx._toggle();\n            return $event.stopPropagation();\n          })(\"keydown.Enter\", function CdkTreeNodeToggle_keydown_Enter_HostBindingHandler($event) {\n            ctx._toggle();\n            return $event.preventDefault();\n          })(\"keydown.Space\", function CdkTreeNodeToggle_keydown_Space_HostBindingHandler($event) {\n            ctx._toggle();\n            return $event.preventDefault();\n          });\n        }\n      },\n      inputs: {\n        recursive: [2, \"cdkTreeNodeToggleRecursive\", \"recursive\", booleanAttribute]\n      },\n      standalone: true,\n      features: [i0.ɵɵInputTransformsFeature]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkTreeNodeToggle, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkTreeNodeToggle]',\n      host: {\n        '(click)': '_toggle(); $event.stopPropagation();',\n        '(keydown.Enter)': '_toggle(); $event.preventDefault();',\n        '(keydown.Space)': '_toggle(); $event.preventDefault();',\n        'tabindex': '-1'\n      },\n      standalone: true\n    }]\n  }], () => [{\n    type: CdkTree\n  }, {\n    type: CdkTreeNode\n  }], {\n    recursive: [{\n      type: Input,\n      args: [{\n        alias: 'cdkTreeNodeToggleRecursive',\n        transform: booleanAttribute\n      }]\n    }]\n  });\n})();\nconst EXPORTED_DECLARATIONS = [CdkNestedTreeNode, CdkTreeNodeDef, CdkTreeNodePadding, CdkTreeNodeToggle, CdkTree, CdkTreeNode, CdkTreeNodeOutlet];\nclass CdkTreeModule {\n  static {\n    this.ɵfac = function CdkTreeModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeModule)();\n    };\n  }\n  static {\n    this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: CdkTreeModule\n    });\n  }\n  static {\n    this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkTreeModule, [{\n    type: NgModule,\n    args: [{\n      imports: EXPORTED_DECLARATIONS,\n      exports: EXPORTED_DECLARATIONS\n    }]\n  }], null, null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BaseTreeControl, CDK_TREE_NODE_OUTLET_NODE, CdkNestedTreeNode, CdkTree, CdkTreeModule, CdkTreeNode, CdkTreeNodeDef, CdkTreeNodeOutlet, CdkTreeNodeOutletContext, CdkTreeNodePadding, CdkTreeNodeToggle, FlatTreeControl, NestedTreeControl, getMultipleTreeControlsError, getTreeControlMissingError, getTreeMissingMatchingNodeDefError, getTreeMultipleDefaultNodeDefsError, getTreeNoValidDataSourceError };","map":{"version":3,"names":["SelectionModel","isDataSource","isObservable","Subject","BehaviorSubject","of","combineLatest","EMPTY","concat","take","filter","takeUntil","startWith","tap","switchMap","map","reduce","concatMap","distinctUntilChanged","i0","InjectionToken","Directive","Inject","Optional","inject","Component","ViewEncapsulation","ChangeDetectionStrategy","Input","ViewChild","ContentChildren","EventEmitter","ChangeDetectorRef","booleanAttribute","Output","numberAttribute","NgModule","TREE_KEY_MANAGER","i2","Directionality","coerceObservable","BaseTreeControl","constructor","expansionModel","toggle","dataNode","_trackByValue","expand","select","collapse","deselect","isExpanded","isSelected","toggleDescendants","collapseDescendants","expandDescendants","collapseAll","clear","toBeProcessed","push","getDescendants","value","trackBy","FlatTreeControl","getLevel","isExpandable","options","startIndex","dataNodes","indexOf","results","i","length","expandAll","node","NestedTreeControl","getChildren","allNodes","accumulator","descendants","_getDescendants","splice","childrenNodes","Array","isArray","forEach","child","pipe","Boolean","subscribe","children","CDK_TREE_NODE_OUTLET_NODE","CdkTreeNodeOutlet","viewContainer","_node","ɵfac","CdkTreeNodeOutlet_Factory","__ngFactoryType__","ɵɵdirectiveInject","ViewContainerRef","ɵdir","ɵɵdefineDirective","type","selectors","standalone","ngDevMode","ɵsetClassMetadata","args","selector","undefined","decorators","CdkTreeNodeOutletContext","data","$implicit","CdkTreeNodeDef","template","CdkTreeNodeDef_Factory","TemplateRef","inputs","when","name","alias","getTreeNoValidDataSourceError","Error","getTreeMultipleDefaultNodeDefsError","getTreeMissingMatchingNodeDefError","getTreeControlMissingError","getMultipleTreeControlsError","CdkTree","dataSource","_dataSource","_switchDataSource","_differs","_changeDetectorRef","_dir","_onDestroy","_levels","Map","_parents","_ariaSets","viewChange","start","end","Number","MAX_VALUE","_flattenedNodes","_nodeType","_nodes","_keyManagerNodes","_keyManagerFactory","_viewInit","ngAfterContentInit","_initializeKeyManager","ngAfterContentChecked","_updateDefaultNodeDefinition","_subscribeToDataChanges","ngOnDestroy","_nodeOutlet","complete","next","disconnect","_dataSubscription","unsubscribe","_keyManager","destroy","ngOnInit","_checkTreeControlUsage","_initializeDataDiffer","ngAfterViewInit","defaultNodeDefs","_nodeDefs","def","_defaultNodeDef","_setNodeTypeIfUnset","nodeType","_getExpansionModel","treeControl","_expansionModel","dataStream","connect","_getRenderData","renderingData","_renderDataChanges","changed","expansionChanges","_emitExpansionChanges","renderNodes","flattenedNodes","_computeRenderingData","convertedData","renderNodeChanges","_updateCachedData","_updateKeyManagerItems","nodes","added","get","_emitExpansionState","removed","items","keyManagerNodes","_getExpansionKey","keyManagerOptions","skipPredicate","isDisabled","typeAheadDebounceInterval","horizontalOrientation","_index","item","_dataDiffer","find","create","numTreeControls","levelAccessor","childrenAccessor","dataDiffer","parentData","changes","diff","forEachOperation","adjustedPreviousIndex","currentIndex","previousIndex","insertNode","remove","view","move","forEachIdentityChange","record","newData","context","markForCheck","detectChanges","_getNodeDef","first","nodeDef","nodeData","index","_getLevelAccessor","key","level","has","set","container","createEmbeddedView","CdkTreeNode","mostRecentTreeNode","bind","_getChildrenAccessor","_getDirectChildren","includes","expanded","_findChildrenByLevel","levelDelta","findIndex","dataNodeLevel","expectedLevel","currentLevel","_registerNode","_unregisterNode","delete","_getLevel","_getSetSize","_getAriaSet","_getPositionInSet","_getNodeParent","parent","_getNodeChildren","_sendKeydownToKeyManager","event","onKeydown","Infinity","_getAllChildrenRecursively","allChildren","nextChildren","expansionKey","parentKey","_findParentForNode","cachedNodes","parentIndex","parentNode","parentLevel","_flattenNestedNodesWithExpansion","childNodes","childKey","nestedNodes","rootNodes","_calculateParents","group","CdkTree_Factory","IterableDiffers","ɵcmp","ɵɵdefineComponent","contentQueries","CdkTree_ContentQueries","rf","ctx","dirIndex","ɵɵcontentQuery","_t","ɵɵqueryRefresh","ɵɵloadQuery","viewQuery","CdkTree_Query","ɵɵviewQuery","hostAttrs","hostBindings","CdkTree_HostBindings","ɵɵlistener","CdkTree_keydown_HostBindingHandler","$event","exportAs","features","ɵɵStandaloneFeature","decls","vars","consts","CdkTree_Template","ɵɵelementContainer","dependencies","encapsulation","host","None","changeDetection","Default","imports","static","role","_role","_isExpandable","_inputIsExpandable","_inputIsExpanded","_tree","_data","getLabel","typeaheadLabel","_elementRef","nativeElement","textContent","trim","_dataChanges","isLeafNode","_parentNodeAriaLevel","_getAriaExpanded","String","_tabindex","activation","expandedChange","_destroyed","_shouldFocus","getParentNodeAriaLevel","getParent","focus","unfocus","activate","makeFocusable","_focusItem","focusItem","_setActiveItem","emit","CdkTreeNode_Factory","ElementRef","hostVars","CdkTreeNode_HostBindings","CdkTreeNode_click_HostBindingHandler","CdkTreeNode_focus_HostBindingHandler","ɵɵhostProperty","ɵɵattribute","outputs","ɵɵInputTransformsFeature","transform","nodeElement","parentElement","isNodeElement","classList","contains","getAttribute","element","CdkNestedTreeNode","elementRef","tree","result","updateChildrenNodes","nodeOutlet","_clear","outlet","_getNodeOutlet","_children","outlets","CdkNestedTreeNode_Factory","CdkNestedTreeNode_ContentQueries","ɵɵProvidersFeature","provide","useExisting","ɵɵInheritDefinitionFeature","providers","cssUnitPattern","CdkTreeNodePadding","_level","_setLevelInput","indent","_indent","_setIndentInput","_treeNode","_element","indentUnits","_setPadding","change","_paddingIndent","nodeLevel","forceChange","padding","_currentPadding","paddingProp","resetProp","style","isNaN","units","parts","split","CdkTreeNodePadding_Factory","CdkTreeNodeToggle","recursive","_toggle","CdkTreeNodeToggle_Factory","CdkTreeNodeToggle_HostBindings","CdkTreeNodeToggle_click_HostBindingHandler","stopPropagation","CdkTreeNodeToggle_keydown_Enter_HostBindingHandler","preventDefault","CdkTreeNodeToggle_keydown_Space_HostBindingHandler","EXPORTED_DECLARATIONS","CdkTreeModule","CdkTreeModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","exports"],"sources":["D:/UNIVERSIDAD/TRABAJOS free/Oscar Robayo/front-agroconecta/node_modules/@angular/cdk/fesm2022/tree.mjs"],"sourcesContent":["import { SelectionModel, isDataSource } from '@angular/cdk/collections';\nimport { isObservable, Subject, BehaviorSubject, of, combineLatest, EMPTY, concat } from 'rxjs';\nimport { take, filter, takeUntil, startWith, tap, switchMap, map, reduce, concatMap, distinctUntilChanged } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Directive, Inject, Optional, inject, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, ViewChild, ContentChildren, EventEmitter, ChangeDetectorRef, booleanAttribute, Output, numberAttribute, NgModule } from '@angular/core';\nimport { TREE_KEY_MANAGER } from '@angular/cdk/a11y';\nimport * as i2 from '@angular/cdk/bidi';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { coerceObservable } from '@angular/cdk/coercion/private';\n\n/**\n * Base tree control. It has basic toggle/expand/collapse operations on a single data node.\n *\n * @deprecated Use one of levelAccessor or childrenAccessor. To be removed in a future version.\n * @breaking-change 21.0.0\n */\nclass BaseTreeControl {\n    constructor() {\n        /** A selection model with multi-selection to track expansion status. */\n        this.expansionModel = new SelectionModel(true);\n    }\n    /** Toggles one single data node's expanded/collapsed state. */\n    toggle(dataNode) {\n        this.expansionModel.toggle(this._trackByValue(dataNode));\n    }\n    /** Expands one single data node. */\n    expand(dataNode) {\n        this.expansionModel.select(this._trackByValue(dataNode));\n    }\n    /** Collapses one single data node. */\n    collapse(dataNode) {\n        this.expansionModel.deselect(this._trackByValue(dataNode));\n    }\n    /** Whether a given data node is expanded or not. Returns true if the data node is expanded. */\n    isExpanded(dataNode) {\n        return this.expansionModel.isSelected(this._trackByValue(dataNode));\n    }\n    /** Toggles a subtree rooted at `node` recursively. */\n    toggleDescendants(dataNode) {\n        this.expansionModel.isSelected(this._trackByValue(dataNode))\n            ? this.collapseDescendants(dataNode)\n            : this.expandDescendants(dataNode);\n    }\n    /** Collapse all dataNodes in the tree. */\n    collapseAll() {\n        this.expansionModel.clear();\n    }\n    /** Expands a subtree rooted at given data node recursively. */\n    expandDescendants(dataNode) {\n        let toBeProcessed = [dataNode];\n        toBeProcessed.push(...this.getDescendants(dataNode));\n        this.expansionModel.select(...toBeProcessed.map(value => this._trackByValue(value)));\n    }\n    /** Collapses a subtree rooted at given data node recursively. */\n    collapseDescendants(dataNode) {\n        let toBeProcessed = [dataNode];\n        toBeProcessed.push(...this.getDescendants(dataNode));\n        this.expansionModel.deselect(...toBeProcessed.map(value => this._trackByValue(value)));\n    }\n    _trackByValue(value) {\n        return this.trackBy ? this.trackBy(value) : value;\n    }\n}\n\n/**\n * Flat tree control. Able to expand/collapse a subtree recursively for flattened tree.\n *\n * @deprecated Use one of levelAccessor or childrenAccessor instead. To be removed in a future\n * version.\n * @breaking-change 21.0.0\n */\nclass FlatTreeControl extends BaseTreeControl {\n    /** Construct with flat tree data node functions getLevel and isExpandable. */\n    constructor(getLevel, isExpandable, options) {\n        super();\n        this.getLevel = getLevel;\n        this.isExpandable = isExpandable;\n        this.options = options;\n        if (this.options) {\n            this.trackBy = this.options.trackBy;\n        }\n    }\n    /**\n     * Gets a list of the data node's subtree of descendent data nodes.\n     *\n     * To make this working, the `dataNodes` of the TreeControl must be flattened tree nodes\n     * with correct levels.\n     */\n    getDescendants(dataNode) {\n        const startIndex = this.dataNodes.indexOf(dataNode);\n        const results = [];\n        // Goes through flattened tree nodes in the `dataNodes` array, and get all descendants.\n        // The level of descendants of a tree node must be greater than the level of the given\n        // tree node.\n        // If we reach a node whose level is equal to the level of the tree node, we hit a sibling.\n        // If we reach a node whose level is greater than the level of the tree node, we hit a\n        // sibling of an ancestor.\n        for (let i = startIndex + 1; i < this.dataNodes.length && this.getLevel(dataNode) < this.getLevel(this.dataNodes[i]); i++) {\n            results.push(this.dataNodes[i]);\n        }\n        return results;\n    }\n    /**\n     * Expands all data nodes in the tree.\n     *\n     * To make this working, the `dataNodes` variable of the TreeControl must be set to all flattened\n     * data nodes of the tree.\n     */\n    expandAll() {\n        this.expansionModel.select(...this.dataNodes.map(node => this._trackByValue(node)));\n    }\n}\n\n/**\n * Nested tree control. Able to expand/collapse a subtree recursively for NestedNode type.\n *\n * @deprecated Use one of levelAccessor or childrenAccessor instead. To be removed in a future\n * version.\n * @breaking-change 21.0.0\n */\nclass NestedTreeControl extends BaseTreeControl {\n    /** Construct with nested tree function getChildren. */\n    constructor(getChildren, options) {\n        super();\n        this.getChildren = getChildren;\n        this.options = options;\n        if (this.options) {\n            this.trackBy = this.options.trackBy;\n        }\n        if (this.options?.isExpandable) {\n            this.isExpandable = this.options.isExpandable;\n        }\n    }\n    /**\n     * Expands all dataNodes in the tree.\n     *\n     * To make this working, the `dataNodes` variable of the TreeControl must be set to all root level\n     * data nodes of the tree.\n     */\n    expandAll() {\n        this.expansionModel.clear();\n        const allNodes = this.dataNodes.reduce((accumulator, dataNode) => [...accumulator, ...this.getDescendants(dataNode), dataNode], []);\n        this.expansionModel.select(...allNodes.map(node => this._trackByValue(node)));\n    }\n    /** Gets a list of descendant dataNodes of a subtree rooted at given data node recursively. */\n    getDescendants(dataNode) {\n        const descendants = [];\n        this._getDescendants(descendants, dataNode);\n        // Remove the node itself\n        return descendants.splice(1);\n    }\n    /** A helper function to get descendants recursively. */\n    _getDescendants(descendants, dataNode) {\n        descendants.push(dataNode);\n        const childrenNodes = this.getChildren(dataNode);\n        if (Array.isArray(childrenNodes)) {\n            childrenNodes.forEach((child) => this._getDescendants(descendants, child));\n        }\n        else if (isObservable(childrenNodes)) {\n            // TypeScript as of version 3.5 doesn't seem to treat `Boolean` like a function that\n            // returns a `boolean` specifically in the context of `filter`, so we manually clarify that.\n            childrenNodes.pipe(take(1), filter(Boolean)).subscribe(children => {\n                for (const child of children) {\n                    this._getDescendants(descendants, child);\n                }\n            });\n        }\n    }\n}\n\n/**\n * Injection token used to provide a `CdkTreeNode` to its outlet.\n * Used primarily to avoid circular imports.\n * @docs-private\n */\nconst CDK_TREE_NODE_OUTLET_NODE = new InjectionToken('CDK_TREE_NODE_OUTLET_NODE');\n/**\n * Outlet for nested CdkNode. Put `[cdkTreeNodeOutlet]` on a tag to place children dataNodes\n * inside the outlet.\n */\nclass CdkTreeNodeOutlet {\n    constructor(viewContainer, _node) {\n        this.viewContainer = viewContainer;\n        this._node = _node;\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: CdkTreeNodeOutlet, deps: [{ token: i0.ViewContainerRef }, { token: CDK_TREE_NODE_OUTLET_NODE, optional: true }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"18.2.0-next.2\", type: CdkTreeNodeOutlet, isStandalone: true, selector: \"[cdkTreeNodeOutlet]\", ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: CdkTreeNodeOutlet, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkTreeNodeOutlet]',\n                    standalone: true,\n                }]\n        }], ctorParameters: () => [{ type: i0.ViewContainerRef }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [CDK_TREE_NODE_OUTLET_NODE]\n                }, {\n                    type: Optional\n                }] }] });\n\n/** Context provided to the tree node component. */\nclass CdkTreeNodeOutletContext {\n    constructor(data) {\n        this.$implicit = data;\n    }\n}\n/**\n * Data node definition for the CdkTree.\n * Captures the node's template and a when predicate that describes when this node should be used.\n */\nclass CdkTreeNodeDef {\n    /** @docs-private */\n    constructor(template) {\n        this.template = template;\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: CdkTreeNodeDef, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"18.2.0-next.2\", type: CdkTreeNodeDef, isStandalone: true, selector: \"[cdkTreeNodeDef]\", inputs: { when: [\"cdkTreeNodeDefWhen\", \"when\"] }, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: CdkTreeNodeDef, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkTreeNodeDef]',\n                    inputs: [{ name: 'when', alias: 'cdkTreeNodeDefWhen' }],\n                    standalone: true,\n                }]\n        }], ctorParameters: () => [{ type: i0.TemplateRef }] });\n\n/**\n * Returns an error to be thrown when there is no usable data.\n * @docs-private\n */\nfunction getTreeNoValidDataSourceError() {\n    return Error(`A valid data source must be provided.`);\n}\n/**\n * Returns an error to be thrown when there are multiple nodes that are missing a when function.\n * @docs-private\n */\nfunction getTreeMultipleDefaultNodeDefsError() {\n    return Error(`There can only be one default row without a when predicate function.`);\n}\n/**\n * Returns an error to be thrown when there are no matching node defs for a particular set of data.\n * @docs-private\n */\nfunction getTreeMissingMatchingNodeDefError() {\n    return Error(`Could not find a matching node definition for the provided node data.`);\n}\n/**\n * Returns an error to be thrown when there is no tree control.\n * @docs-private\n */\nfunction getTreeControlMissingError() {\n    return Error(`Could not find a tree control, levelAccessor, or childrenAccessor for the tree.`);\n}\n/**\n * Returns an error to be thrown when there are multiple ways of specifying children or level\n * provided to the tree.\n * @docs-private\n */\nfunction getMultipleTreeControlsError() {\n    return Error(`More than one of tree control, levelAccessor, or childrenAccessor were provided.`);\n}\n\n/**\n * CDK tree component that connects with a data source to retrieve data of type `T` and renders\n * dataNodes with hierarchy. Updates the dataNodes when new data is provided by the data source.\n */\nclass CdkTree {\n    /**\n     * Provides a stream containing the latest data array to render. Influenced by the tree's\n     * stream of view window (what dataNodes are currently on screen).\n     * Data source can be an observable of data array, or a data array to render.\n     */\n    get dataSource() {\n        return this._dataSource;\n    }\n    set dataSource(dataSource) {\n        if (this._dataSource !== dataSource) {\n            this._switchDataSource(dataSource);\n        }\n    }\n    constructor(_differs, _changeDetectorRef) {\n        this._differs = _differs;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._dir = inject(Directionality);\n        /** Subject that emits when the component has been destroyed. */\n        this._onDestroy = new Subject();\n        /** Level of nodes */\n        this._levels = new Map();\n        /** The immediate parents for a node. This is `null` if there is no parent. */\n        this._parents = new Map();\n        /**\n         * Nodes grouped into each set, which is a list of nodes displayed together in the DOM.\n         *\n         * Lookup key is the parent of a set. Root nodes have key of null.\n         *\n         * Values is a 'set' of tree nodes. Each tree node maps to a treeitem element. Sets are in the\n         * order that it is rendered. Each set maps directly to aria-posinset and aria-setsize attributes.\n         */\n        this._ariaSets = new Map();\n        // TODO(tinayuangao): Setup a listener for scrolling, emit the calculated view to viewChange.\n        //     Remove the MAX_VALUE in viewChange\n        /**\n         * Stream containing the latest information on what rows are being displayed on screen.\n         * Can be used by the data source to as a heuristic of what data should be provided.\n         */\n        this.viewChange = new BehaviorSubject({\n            start: 0,\n            end: Number.MAX_VALUE,\n        });\n        /**\n         * Maintain a synchronous cache of flattened data nodes. This will only be\n         * populated after initial render, and in certain cases, will be delayed due to\n         * relying on Observable `getChildren` calls.\n         */\n        this._flattenedNodes = new BehaviorSubject([]);\n        /** The automatically determined node type for the tree. */\n        this._nodeType = new BehaviorSubject(null);\n        /** The mapping between data and the node that is rendered. */\n        this._nodes = new BehaviorSubject(new Map());\n        /**\n         * Synchronous cache of nodes for the `TreeKeyManager`. This is separate\n         * from `_flattenedNodes` so they can be independently updated at different\n         * times.\n         */\n        this._keyManagerNodes = new BehaviorSubject([]);\n        this._keyManagerFactory = inject(TREE_KEY_MANAGER);\n        this._viewInit = false;\n    }\n    ngAfterContentInit() {\n        this._initializeKeyManager();\n    }\n    ngAfterContentChecked() {\n        this._updateDefaultNodeDefinition();\n        this._subscribeToDataChanges();\n    }\n    ngOnDestroy() {\n        this._nodeOutlet.viewContainer.clear();\n        this.viewChange.complete();\n        this._onDestroy.next();\n        this._onDestroy.complete();\n        if (this._dataSource && typeof this._dataSource.disconnect === 'function') {\n            this.dataSource.disconnect(this);\n        }\n        if (this._dataSubscription) {\n            this._dataSubscription.unsubscribe();\n            this._dataSubscription = null;\n        }\n        // In certain tests, the tree might be destroyed before this is initialized\n        // in `ngAfterContentInit`.\n        this._keyManager?.destroy();\n    }\n    ngOnInit() {\n        this._checkTreeControlUsage();\n        this._initializeDataDiffer();\n    }\n    ngAfterViewInit() {\n        this._viewInit = true;\n    }\n    _updateDefaultNodeDefinition() {\n        const defaultNodeDefs = this._nodeDefs.filter(def => !def.when);\n        if (defaultNodeDefs.length > 1 && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getTreeMultipleDefaultNodeDefsError();\n        }\n        this._defaultNodeDef = defaultNodeDefs[0];\n    }\n    /**\n     * Sets the node type for the tree, if it hasn't been set yet.\n     *\n     * This will be called by the first node that's rendered in order for the tree\n     * to determine what data transformations are required.\n     */\n    _setNodeTypeIfUnset(nodeType) {\n        if (this._nodeType.value === null) {\n            this._nodeType.next(nodeType);\n        }\n    }\n    /**\n     * Switch to the provided data source by resetting the data and unsubscribing from the current\n     * render change subscription if one exists. If the data source is null, interpret this by\n     * clearing the node outlet. Otherwise start listening for new data.\n     */\n    _switchDataSource(dataSource) {\n        if (this._dataSource && typeof this._dataSource.disconnect === 'function') {\n            this.dataSource.disconnect(this);\n        }\n        if (this._dataSubscription) {\n            this._dataSubscription.unsubscribe();\n            this._dataSubscription = null;\n        }\n        // Remove the all dataNodes if there is now no data source\n        if (!dataSource) {\n            this._nodeOutlet.viewContainer.clear();\n        }\n        this._dataSource = dataSource;\n        if (this._nodeDefs) {\n            this._subscribeToDataChanges();\n        }\n    }\n    _getExpansionModel() {\n        if (!this.treeControl) {\n            this._expansionModel ??= new SelectionModel(true);\n            return this._expansionModel;\n        }\n        return this.treeControl.expansionModel;\n    }\n    /** Set up a subscription for the data provided by the data source. */\n    _subscribeToDataChanges() {\n        if (this._dataSubscription) {\n            return;\n        }\n        let dataStream;\n        if (isDataSource(this._dataSource)) {\n            dataStream = this._dataSource.connect(this);\n        }\n        else if (isObservable(this._dataSource)) {\n            dataStream = this._dataSource;\n        }\n        else if (Array.isArray(this._dataSource)) {\n            dataStream = of(this._dataSource);\n        }\n        if (!dataStream) {\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                throw getTreeNoValidDataSourceError();\n            }\n            return;\n        }\n        this._dataSubscription = this._getRenderData(dataStream)\n            .pipe(takeUntil(this._onDestroy))\n            .subscribe(renderingData => {\n            this._renderDataChanges(renderingData);\n        });\n    }\n    /** Given an Observable containing a stream of the raw data, returns an Observable containing the RenderingData */\n    _getRenderData(dataStream) {\n        const expansionModel = this._getExpansionModel();\n        return combineLatest([\n            dataStream,\n            this._nodeType,\n            // We don't use the expansion data directly, however we add it here to essentially\n            // trigger data rendering when expansion changes occur.\n            expansionModel.changed.pipe(startWith(null), tap(expansionChanges => {\n                this._emitExpansionChanges(expansionChanges);\n            })),\n        ]).pipe(switchMap(([data, nodeType]) => {\n            if (nodeType === null) {\n                return of({ renderNodes: data, flattenedNodes: null, nodeType });\n            }\n            // If we're here, then we know what our node type is, and therefore can\n            // perform our usual rendering pipeline, which necessitates converting the data\n            return this._computeRenderingData(data, nodeType).pipe(map(convertedData => ({ ...convertedData, nodeType })));\n        }));\n    }\n    _renderDataChanges(data) {\n        if (data.nodeType === null) {\n            this.renderNodeChanges(data.renderNodes);\n            return;\n        }\n        // If we're here, then we know what our node type is, and therefore can\n        // perform our usual rendering pipeline.\n        this._updateCachedData(data.flattenedNodes);\n        this.renderNodeChanges(data.renderNodes);\n        this._updateKeyManagerItems(data.flattenedNodes);\n    }\n    _emitExpansionChanges(expansionChanges) {\n        if (!expansionChanges) {\n            return;\n        }\n        const nodes = this._nodes.value;\n        for (const added of expansionChanges.added) {\n            const node = nodes.get(added);\n            node?._emitExpansionState(true);\n        }\n        for (const removed of expansionChanges.removed) {\n            const node = nodes.get(removed);\n            node?._emitExpansionState(false);\n        }\n    }\n    _initializeKeyManager() {\n        const items = combineLatest([this._keyManagerNodes, this._nodes]).pipe(map(([keyManagerNodes, renderNodes]) => keyManagerNodes.reduce((items, data) => {\n            const node = renderNodes.get(this._getExpansionKey(data));\n            if (node) {\n                items.push(node);\n            }\n            return items;\n        }, [])));\n        const keyManagerOptions = {\n            trackBy: node => this._getExpansionKey(node.data),\n            skipPredicate: node => !!node.isDisabled,\n            typeAheadDebounceInterval: true,\n            horizontalOrientation: this._dir.value,\n        };\n        this._keyManager = this._keyManagerFactory(items, keyManagerOptions);\n    }\n    _initializeDataDiffer() {\n        // Provide a default trackBy based on `_getExpansionKey` if one isn't provided.\n        const trackBy = this.trackBy ?? ((_index, item) => this._getExpansionKey(item));\n        this._dataDiffer = this._differs.find([]).create(trackBy);\n    }\n    _checkTreeControlUsage() {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            // Verify that Tree follows API contract of using one of TreeControl, levelAccessor or\n            // childrenAccessor. Throw an appropriate error if contract is not met.\n            let numTreeControls = 0;\n            if (this.treeControl) {\n                numTreeControls++;\n            }\n            if (this.levelAccessor) {\n                numTreeControls++;\n            }\n            if (this.childrenAccessor) {\n                numTreeControls++;\n            }\n            if (!numTreeControls) {\n                throw getTreeControlMissingError();\n            }\n            else if (numTreeControls > 1) {\n                throw getMultipleTreeControlsError();\n            }\n        }\n    }\n    /** Check for changes made in the data and render each change (node added/removed/moved). */\n    renderNodeChanges(data, dataDiffer = this._dataDiffer, viewContainer = this._nodeOutlet.viewContainer, parentData) {\n        const changes = dataDiffer.diff(data);\n        // Some tree consumers expect change detection to propagate to nodes\n        // even when the array itself hasn't changed; we explicitly detect changes\n        // anyways in order for nodes to update their data.\n        //\n        // However, if change detection is called while the component's view is\n        // still initing, then the order of child views initing will be incorrect;\n        // to prevent this, we only exit early if the view hasn't initialized yet.\n        if (!changes && !this._viewInit) {\n            return;\n        }\n        changes?.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {\n            if (item.previousIndex == null) {\n                this.insertNode(data[currentIndex], currentIndex, viewContainer, parentData);\n            }\n            else if (currentIndex == null) {\n                viewContainer.remove(adjustedPreviousIndex);\n            }\n            else {\n                const view = viewContainer.get(adjustedPreviousIndex);\n                viewContainer.move(view, currentIndex);\n            }\n        });\n        // If the data itself changes, but keeps the same trackBy, we need to update the templates'\n        // context to reflect the new object.\n        changes?.forEachIdentityChange((record) => {\n            const newData = record.item;\n            if (record.currentIndex != undefined) {\n                const view = viewContainer.get(record.currentIndex);\n                view.context.$implicit = newData;\n            }\n        });\n        // Note: we only `detectChanges` from a top-level call, otherwise we risk overflowing\n        // the call stack since this method is called recursively (see #29733.)\n        // TODO: change to `this._changeDetectorRef.markForCheck()`,\n        // or just switch this component to use signals.\n        if (parentData) {\n            this._changeDetectorRef.markForCheck();\n        }\n        else {\n            this._changeDetectorRef.detectChanges();\n        }\n    }\n    /**\n     * Finds the matching node definition that should be used for this node data. If there is only\n     * one node definition, it is returned. Otherwise, find the node definition that has a when\n     * predicate that returns true with the data. If none return true, return the default node\n     * definition.\n     */\n    _getNodeDef(data, i) {\n        if (this._nodeDefs.length === 1) {\n            return this._nodeDefs.first;\n        }\n        const nodeDef = this._nodeDefs.find(def => def.when && def.when(i, data)) || this._defaultNodeDef;\n        if (!nodeDef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getTreeMissingMatchingNodeDefError();\n        }\n        return nodeDef;\n    }\n    /**\n     * Create the embedded view for the data node template and place it in the correct index location\n     * within the data node view container.\n     */\n    insertNode(nodeData, index, viewContainer, parentData) {\n        const levelAccessor = this._getLevelAccessor();\n        const node = this._getNodeDef(nodeData, index);\n        const key = this._getExpansionKey(nodeData);\n        // Node context that will be provided to created embedded view\n        const context = new CdkTreeNodeOutletContext(nodeData);\n        parentData ??= this._parents.get(key) ?? undefined;\n        // If the tree is flat tree, then use the `getLevel` function in flat tree control\n        // Otherwise, use the level of parent node.\n        if (levelAccessor) {\n            context.level = levelAccessor(nodeData);\n        }\n        else if (parentData !== undefined && this._levels.has(this._getExpansionKey(parentData))) {\n            context.level = this._levels.get(this._getExpansionKey(parentData)) + 1;\n        }\n        else {\n            context.level = 0;\n        }\n        this._levels.set(key, context.level);\n        // Use default tree nodeOutlet, or nested node's nodeOutlet\n        const container = viewContainer ? viewContainer : this._nodeOutlet.viewContainer;\n        container.createEmbeddedView(node.template, context, index);\n        // Set the data to just created `CdkTreeNode`.\n        // The `CdkTreeNode` created from `createEmbeddedView` will be saved in static variable\n        //     `mostRecentTreeNode`. We get it from static variable and pass the node data to it.\n        if (CdkTreeNode.mostRecentTreeNode) {\n            CdkTreeNode.mostRecentTreeNode.data = nodeData;\n        }\n    }\n    /** Whether the data node is expanded or collapsed. Returns true if it's expanded. */\n    isExpanded(dataNode) {\n        return !!(this.treeControl?.isExpanded(dataNode) ||\n            this._expansionModel?.isSelected(this._getExpansionKey(dataNode)));\n    }\n    /** If the data node is currently expanded, collapse it. Otherwise, expand it. */\n    toggle(dataNode) {\n        if (this.treeControl) {\n            this.treeControl.toggle(dataNode);\n        }\n        else if (this._expansionModel) {\n            this._expansionModel.toggle(this._getExpansionKey(dataNode));\n        }\n    }\n    /** Expand the data node. If it is already expanded, does nothing. */\n    expand(dataNode) {\n        if (this.treeControl) {\n            this.treeControl.expand(dataNode);\n        }\n        else if (this._expansionModel) {\n            this._expansionModel.select(this._getExpansionKey(dataNode));\n        }\n    }\n    /** Collapse the data node. If it is already collapsed, does nothing. */\n    collapse(dataNode) {\n        if (this.treeControl) {\n            this.treeControl.collapse(dataNode);\n        }\n        else if (this._expansionModel) {\n            this._expansionModel.deselect(this._getExpansionKey(dataNode));\n        }\n    }\n    /**\n     * If the data node is currently expanded, collapse it and all its descendants.\n     * Otherwise, expand it and all its descendants.\n     */\n    toggleDescendants(dataNode) {\n        if (this.treeControl) {\n            this.treeControl.toggleDescendants(dataNode);\n        }\n        else if (this._expansionModel) {\n            if (this.isExpanded(dataNode)) {\n                this.collapseDescendants(dataNode);\n            }\n            else {\n                this.expandDescendants(dataNode);\n            }\n        }\n    }\n    /**\n     * Expand the data node and all its descendants. If they are already expanded, does nothing.\n     */\n    expandDescendants(dataNode) {\n        if (this.treeControl) {\n            this.treeControl.expandDescendants(dataNode);\n        }\n        else if (this._expansionModel) {\n            const expansionModel = this._expansionModel;\n            expansionModel.select(this._getExpansionKey(dataNode));\n            this._getDescendants(dataNode)\n                .pipe(take(1), takeUntil(this._onDestroy))\n                .subscribe(children => {\n                expansionModel.select(...children.map(child => this._getExpansionKey(child)));\n            });\n        }\n    }\n    /** Collapse the data node and all its descendants. If it is already collapsed, does nothing. */\n    collapseDescendants(dataNode) {\n        if (this.treeControl) {\n            this.treeControl.collapseDescendants(dataNode);\n        }\n        else if (this._expansionModel) {\n            const expansionModel = this._expansionModel;\n            expansionModel.deselect(this._getExpansionKey(dataNode));\n            this._getDescendants(dataNode)\n                .pipe(take(1), takeUntil(this._onDestroy))\n                .subscribe(children => {\n                expansionModel.deselect(...children.map(child => this._getExpansionKey(child)));\n            });\n        }\n    }\n    /** Expands all data nodes in the tree. */\n    expandAll() {\n        if (this.treeControl) {\n            this.treeControl.expandAll();\n        }\n        else if (this._expansionModel) {\n            const expansionModel = this._expansionModel;\n            expansionModel.select(...this._flattenedNodes.value.map(child => this._getExpansionKey(child)));\n        }\n    }\n    /** Collapse all data nodes in the tree. */\n    collapseAll() {\n        if (this.treeControl) {\n            this.treeControl.collapseAll();\n        }\n        else if (this._expansionModel) {\n            const expansionModel = this._expansionModel;\n            expansionModel.deselect(...this._flattenedNodes.value.map(child => this._getExpansionKey(child)));\n        }\n    }\n    /** Level accessor, used for compatibility between the old Tree and new Tree */\n    _getLevelAccessor() {\n        return this.treeControl?.getLevel?.bind(this.treeControl) ?? this.levelAccessor;\n    }\n    /** Children accessor, used for compatibility between the old Tree and new Tree */\n    _getChildrenAccessor() {\n        return this.treeControl?.getChildren?.bind(this.treeControl) ?? this.childrenAccessor;\n    }\n    /**\n     * Gets the direct children of a node; used for compatibility between the old tree and the\n     * new tree.\n     */\n    _getDirectChildren(dataNode) {\n        const levelAccessor = this._getLevelAccessor();\n        const expansionModel = this._expansionModel ?? this.treeControl?.expansionModel;\n        if (!expansionModel) {\n            return of([]);\n        }\n        const key = this._getExpansionKey(dataNode);\n        const isExpanded = expansionModel.changed.pipe(switchMap(changes => {\n            if (changes.added.includes(key)) {\n                return of(true);\n            }\n            else if (changes.removed.includes(key)) {\n                return of(false);\n            }\n            return EMPTY;\n        }), startWith(this.isExpanded(dataNode)));\n        if (levelAccessor) {\n            return combineLatest([isExpanded, this._flattenedNodes]).pipe(map(([expanded, flattenedNodes]) => {\n                if (!expanded) {\n                    return [];\n                }\n                return this._findChildrenByLevel(levelAccessor, flattenedNodes, dataNode, 1);\n            }));\n        }\n        const childrenAccessor = this._getChildrenAccessor();\n        if (childrenAccessor) {\n            return coerceObservable(childrenAccessor(dataNode) ?? []);\n        }\n        throw getTreeControlMissingError();\n    }\n    /**\n     * Given the list of flattened nodes, the level accessor, and the level range within\n     * which to consider children, finds the children for a given node.\n     *\n     * For example, for direct children, `levelDelta` would be 1. For all descendants,\n     * `levelDelta` would be Infinity.\n     */\n    _findChildrenByLevel(levelAccessor, flattenedNodes, dataNode, levelDelta) {\n        const key = this._getExpansionKey(dataNode);\n        const startIndex = flattenedNodes.findIndex(node => this._getExpansionKey(node) === key);\n        const dataNodeLevel = levelAccessor(dataNode);\n        const expectedLevel = dataNodeLevel + levelDelta;\n        const results = [];\n        // Goes through flattened tree nodes in the `flattenedNodes` array, and get all\n        // descendants within a certain level range.\n        //\n        // If we reach a node whose level is equal to or less than the level of the tree node,\n        // we hit a sibling or parent's sibling, and should stop.\n        for (let i = startIndex + 1; i < flattenedNodes.length; i++) {\n            const currentLevel = levelAccessor(flattenedNodes[i]);\n            if (currentLevel <= dataNodeLevel) {\n                break;\n            }\n            if (currentLevel <= expectedLevel) {\n                results.push(flattenedNodes[i]);\n            }\n        }\n        return results;\n    }\n    /**\n     * Adds the specified node component to the tree's internal registry.\n     *\n     * This primarily facilitates keyboard navigation.\n     */\n    _registerNode(node) {\n        this._nodes.value.set(this._getExpansionKey(node.data), node);\n        this._nodes.next(this._nodes.value);\n    }\n    /** Removes the specified node component from the tree's internal registry. */\n    _unregisterNode(node) {\n        this._nodes.value.delete(this._getExpansionKey(node.data));\n        this._nodes.next(this._nodes.value);\n    }\n    /**\n     * For the given node, determine the level where this node appears in the tree.\n     *\n     * This is intended to be used for `aria-level` but is 0-indexed.\n     */\n    _getLevel(node) {\n        return this._levels.get(this._getExpansionKey(node));\n    }\n    /**\n     * For the given node, determine the size of the parent's child set.\n     *\n     * This is intended to be used for `aria-setsize`.\n     */\n    _getSetSize(dataNode) {\n        const set = this._getAriaSet(dataNode);\n        return set.length;\n    }\n    /**\n     * For the given node, determine the index (starting from 1) of the node in its parent's child set.\n     *\n     * This is intended to be used for `aria-posinset`.\n     */\n    _getPositionInSet(dataNode) {\n        const set = this._getAriaSet(dataNode);\n        const key = this._getExpansionKey(dataNode);\n        return set.findIndex(node => this._getExpansionKey(node) === key) + 1;\n    }\n    /** Given a CdkTreeNode, gets the node that renders that node's parent's data. */\n    _getNodeParent(node) {\n        const parent = this._parents.get(this._getExpansionKey(node.data));\n        return parent && this._nodes.value.get(this._getExpansionKey(parent));\n    }\n    /** Given a CdkTreeNode, gets the nodes that renders that node's child data. */\n    _getNodeChildren(node) {\n        return this._getDirectChildren(node.data).pipe(map(children => children.reduce((nodes, child) => {\n            const value = this._nodes.value.get(this._getExpansionKey(child));\n            if (value) {\n                nodes.push(value);\n            }\n            return nodes;\n        }, [])));\n    }\n    /** `keydown` event handler; this just passes the event to the `TreeKeyManager`. */\n    _sendKeydownToKeyManager(event) {\n        this._keyManager.onKeydown(event);\n    }\n    /** Gets all nested descendants of a given node. */\n    _getDescendants(dataNode) {\n        if (this.treeControl) {\n            return of(this.treeControl.getDescendants(dataNode));\n        }\n        if (this.levelAccessor) {\n            const results = this._findChildrenByLevel(this.levelAccessor, this._flattenedNodes.value, dataNode, Infinity);\n            return of(results);\n        }\n        if (this.childrenAccessor) {\n            return this._getAllChildrenRecursively(dataNode).pipe(reduce((allChildren, nextChildren) => {\n                allChildren.push(...nextChildren);\n                return allChildren;\n            }, []));\n        }\n        throw getTreeControlMissingError();\n    }\n    /**\n     * Gets all children and sub-children of the provided node.\n     *\n     * This will emit multiple times, in the order that the children will appear\n     * in the tree, and can be combined with a `reduce` operator.\n     */\n    _getAllChildrenRecursively(dataNode) {\n        if (!this.childrenAccessor) {\n            return of([]);\n        }\n        return coerceObservable(this.childrenAccessor(dataNode)).pipe(take(1), switchMap(children => {\n            // Here, we cache the parents of a particular child so that we can compute the levels.\n            for (const child of children) {\n                this._parents.set(this._getExpansionKey(child), dataNode);\n            }\n            return of(...children).pipe(concatMap(child => concat(of([child]), this._getAllChildrenRecursively(child))));\n        }));\n    }\n    _getExpansionKey(dataNode) {\n        // In the case that a key accessor function was not provided by the\n        // tree user, we'll default to using the node object itself as the key.\n        //\n        // This cast is safe since:\n        // - if an expansionKey is provided, TS will infer the type of K to be\n        //   the return type.\n        // - if it's not, then K will be defaulted to T.\n        return this.expansionKey?.(dataNode) ?? dataNode;\n    }\n    _getAriaSet(node) {\n        const key = this._getExpansionKey(node);\n        const parent = this._parents.get(key);\n        const parentKey = parent ? this._getExpansionKey(parent) : null;\n        const set = this._ariaSets.get(parentKey);\n        return set ?? [node];\n    }\n    /**\n     * Finds the parent for the given node. If this is a root node, this\n     * returns null. If we're unable to determine the parent, for example,\n     * if we don't have cached node data, this returns undefined.\n     */\n    _findParentForNode(node, index, cachedNodes) {\n        // In all cases, we have a mapping from node to level; all we need to do here is backtrack in\n        // our flattened list of nodes to determine the first node that's of a level lower than the\n        // provided node.\n        if (!cachedNodes.length) {\n            return null;\n        }\n        const currentLevel = this._levels.get(this._getExpansionKey(node)) ?? 0;\n        for (let parentIndex = index - 1; parentIndex >= 0; parentIndex--) {\n            const parentNode = cachedNodes[parentIndex];\n            const parentLevel = this._levels.get(this._getExpansionKey(parentNode)) ?? 0;\n            if (parentLevel < currentLevel) {\n                return parentNode;\n            }\n        }\n        return null;\n    }\n    /**\n     * Given a set of root nodes and the current node level, flattens any nested\n     * nodes into a single array.\n     *\n     * If any nodes are not expanded, then their children will not be added into the array.\n     * This will still traverse all nested children in order to build up our internal data\n     * models, but will not include them in the returned array.\n     */\n    _flattenNestedNodesWithExpansion(nodes, level = 0) {\n        const childrenAccessor = this._getChildrenAccessor();\n        // If we're using a level accessor, we don't need to flatten anything.\n        if (!childrenAccessor) {\n            return of([...nodes]);\n        }\n        return of(...nodes).pipe(concatMap(node => {\n            const parentKey = this._getExpansionKey(node);\n            if (!this._parents.has(parentKey)) {\n                this._parents.set(parentKey, null);\n            }\n            this._levels.set(parentKey, level);\n            const children = coerceObservable(childrenAccessor(node));\n            return concat(of([node]), children.pipe(take(1), tap(childNodes => {\n                this._ariaSets.set(parentKey, [...(childNodes ?? [])]);\n                for (const child of childNodes ?? []) {\n                    const childKey = this._getExpansionKey(child);\n                    this._parents.set(childKey, node);\n                    this._levels.set(childKey, level + 1);\n                }\n            }), switchMap(childNodes => {\n                if (!childNodes) {\n                    return of([]);\n                }\n                return this._flattenNestedNodesWithExpansion(childNodes, level + 1).pipe(map(nestedNodes => (this.isExpanded(node) ? nestedNodes : [])));\n            })));\n        }), reduce((results, children) => {\n            results.push(...children);\n            return results;\n        }, []));\n    }\n    /**\n     * Converts children for certain tree configurations.\n     *\n     * This also computes parent, level, and group data.\n     */\n    _computeRenderingData(nodes, nodeType) {\n        // The only situations where we have to convert children types is when\n        // they're mismatched; i.e. if the tree is using a childrenAccessor and the\n        // nodes are flat, or if the tree is using a levelAccessor and the nodes are\n        // nested.\n        if (this.childrenAccessor && nodeType === 'flat') {\n            // This flattens children into a single array.\n            this._ariaSets.set(null, [...nodes]);\n            return this._flattenNestedNodesWithExpansion(nodes).pipe(map(flattenedNodes => ({\n                renderNodes: flattenedNodes,\n                flattenedNodes,\n            })));\n        }\n        else if (this.levelAccessor && nodeType === 'nested') {\n            // In the nested case, we only look for root nodes. The CdkNestedNode\n            // itself will handle rendering each individual node's children.\n            const levelAccessor = this.levelAccessor;\n            return of(nodes.filter(node => levelAccessor(node) === 0)).pipe(map(rootNodes => ({\n                renderNodes: rootNodes,\n                flattenedNodes: nodes,\n            })), tap(({ flattenedNodes }) => {\n                this._calculateParents(flattenedNodes);\n            }));\n        }\n        else if (nodeType === 'flat') {\n            // In the case of a TreeControl, we know that the node type matches up\n            // with the TreeControl, and so no conversions are necessary. Otherwise,\n            // we've already confirmed that the data model matches up with the\n            // desired node type here.\n            return of({ renderNodes: nodes, flattenedNodes: nodes }).pipe(tap(({ flattenedNodes }) => {\n                this._calculateParents(flattenedNodes);\n            }));\n        }\n        else {\n            // For nested nodes, we still need to perform the node flattening in order\n            // to maintain our caches for various tree operations.\n            this._ariaSets.set(null, [...nodes]);\n            return this._flattenNestedNodesWithExpansion(nodes).pipe(map(flattenedNodes => ({\n                renderNodes: nodes,\n                flattenedNodes,\n            })));\n        }\n    }\n    _updateCachedData(flattenedNodes) {\n        this._flattenedNodes.next(flattenedNodes);\n    }\n    _updateKeyManagerItems(flattenedNodes) {\n        this._keyManagerNodes.next(flattenedNodes);\n    }\n    /** Traverse the flattened node data and compute parents, levels, and group data. */\n    _calculateParents(flattenedNodes) {\n        const levelAccessor = this._getLevelAccessor();\n        if (!levelAccessor) {\n            return;\n        }\n        this._parents.clear();\n        this._ariaSets.clear();\n        for (let index = 0; index < flattenedNodes.length; index++) {\n            const dataNode = flattenedNodes[index];\n            const key = this._getExpansionKey(dataNode);\n            this._levels.set(key, levelAccessor(dataNode));\n            const parent = this._findParentForNode(dataNode, index, flattenedNodes);\n            this._parents.set(key, parent);\n            const parentKey = parent ? this._getExpansionKey(parent) : null;\n            const group = this._ariaSets.get(parentKey) ?? [];\n            group.splice(index, 0, dataNode);\n            this._ariaSets.set(parentKey, group);\n        }\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: CdkTree, deps: [{ token: i0.IterableDiffers }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"18.2.0-next.2\", type: CdkTree, isStandalone: true, selector: \"cdk-tree\", inputs: { dataSource: \"dataSource\", treeControl: \"treeControl\", levelAccessor: \"levelAccessor\", childrenAccessor: \"childrenAccessor\", trackBy: \"trackBy\", expansionKey: \"expansionKey\" }, host: { attributes: { \"role\": \"tree\" }, listeners: { \"keydown\": \"_sendKeydownToKeyManager($event)\" }, classAttribute: \"cdk-tree\" }, queries: [{ propertyName: \"_nodeDefs\", predicate: CdkTreeNodeDef, descendants: true }], viewQueries: [{ propertyName: \"_nodeOutlet\", first: true, predicate: CdkTreeNodeOutlet, descendants: true, static: true }], exportAs: [\"cdkTree\"], ngImport: i0, template: `<ng-container cdkTreeNodeOutlet></ng-container>`, isInline: true, dependencies: [{ kind: \"directive\", type: CdkTreeNodeOutlet, selector: \"[cdkTreeNodeOutlet]\" }], changeDetection: i0.ChangeDetectionStrategy.Default, encapsulation: i0.ViewEncapsulation.None }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: CdkTree, decorators: [{\n            type: Component,\n            args: [{\n                    selector: 'cdk-tree',\n                    exportAs: 'cdkTree',\n                    template: `<ng-container cdkTreeNodeOutlet></ng-container>`,\n                    host: {\n                        'class': 'cdk-tree',\n                        'role': 'tree',\n                        '(keydown)': '_sendKeydownToKeyManager($event)',\n                    },\n                    encapsulation: ViewEncapsulation.None,\n                    // The \"OnPush\" status for the `CdkTree` component is effectively a noop, so we are removing it.\n                    // The view for `CdkTree` consists entirely of templates declared in other views. As they are\n                    // declared elsewhere, they are checked when their declaration points are checked.\n                    // tslint:disable-next-line:validate-decorators\n                    changeDetection: ChangeDetectionStrategy.Default,\n                    standalone: true,\n                    imports: [CdkTreeNodeOutlet],\n                }]\n        }], ctorParameters: () => [{ type: i0.IterableDiffers }, { type: i0.ChangeDetectorRef }], propDecorators: { dataSource: [{\n                type: Input\n            }], treeControl: [{\n                type: Input\n            }], levelAccessor: [{\n                type: Input\n            }], childrenAccessor: [{\n                type: Input\n            }], trackBy: [{\n                type: Input\n            }], expansionKey: [{\n                type: Input\n            }], _nodeOutlet: [{\n                type: ViewChild,\n                args: [CdkTreeNodeOutlet, { static: true }]\n            }], _nodeDefs: [{\n                type: ContentChildren,\n                args: [CdkTreeNodeDef, {\n                        // We need to use `descendants: true`, because Ivy will no longer match\n                        // indirect descendants if it's left as false.\n                        descendants: true,\n                    }]\n            }] } });\n/**\n * Tree node for CdkTree. It contains the data in the tree node.\n */\nclass CdkTreeNode {\n    /**\n     * The role of the tree node.\n     *\n     * @deprecated This will be ignored; the tree will automatically determine the appropriate role\n     * for tree node. This input will be removed in a future version.\n     * @breaking-change 21.0.0\n     */\n    get role() {\n        return 'treeitem';\n    }\n    set role(_role) {\n        // ignore any role setting, we handle this internally.\n    }\n    /**\n     * Whether or not this node is expandable.\n     *\n     * If not using `FlatTreeControl`, or if `isExpandable` is not provided to\n     * `NestedTreeControl`, this should be provided for correct node a11y.\n     */\n    get isExpandable() {\n        return this._isExpandable();\n    }\n    set isExpandable(isExpandable) {\n        this._inputIsExpandable = isExpandable;\n        if ((this.data && !this._isExpandable) || !this._inputIsExpandable) {\n            return;\n        }\n        // If the node is being set to expandable, ensure that the status of the\n        // node is propagated\n        if (this._inputIsExpanded) {\n            this.expand();\n        }\n        else if (this._inputIsExpanded === false) {\n            this.collapse();\n        }\n    }\n    get isExpanded() {\n        return this._tree.isExpanded(this._data);\n    }\n    set isExpanded(isExpanded) {\n        this._inputIsExpanded = isExpanded;\n        if (isExpanded) {\n            this.expand();\n        }\n        else {\n            this.collapse();\n        }\n    }\n    getLabel() {\n        return this.typeaheadLabel || this._elementRef.nativeElement.textContent?.trim() || '';\n    }\n    /**\n     * The most recently created `CdkTreeNode`. We save it in static variable so we can retrieve it\n     * in `CdkTree` and set the data to it.\n     */\n    static { this.mostRecentTreeNode = null; }\n    /** The tree node's data. */\n    get data() {\n        return this._data;\n    }\n    set data(value) {\n        if (value !== this._data) {\n            this._data = value;\n            this._dataChanges.next();\n        }\n    }\n    /* If leaf node, return true to not assign aria-expanded attribute */\n    get isLeafNode() {\n        // If flat tree node data returns false for expandable property, it's a leaf node\n        if (this._tree.treeControl?.isExpandable !== undefined &&\n            !this._tree.treeControl.isExpandable(this._data)) {\n            return true;\n            // If nested tree node data returns 0 descendants, it's a leaf node\n        }\n        else if (this._tree.treeControl?.isExpandable === undefined &&\n            this._tree.treeControl?.getDescendants(this._data).length === 0) {\n            return true;\n        }\n        return false;\n    }\n    get level() {\n        // If the tree has a levelAccessor, use it to get the level. Otherwise read the\n        // aria-level off the parent node and use it as the level for this node (note aria-level is\n        // 1-indexed, while this property is 0-indexed, so we don't need to increment).\n        return this._tree._getLevel(this._data) ?? this._parentNodeAriaLevel;\n    }\n    /** Determines if the tree node is expandable. */\n    _isExpandable() {\n        if (this._tree.treeControl) {\n            if (this.isLeafNode) {\n                return false;\n            }\n            // For compatibility with trees created using TreeControl before we added\n            // CdkTreeNode#isExpandable.\n            return true;\n        }\n        return this._inputIsExpandable;\n    }\n    /**\n     * Determines the value for `aria-expanded`.\n     *\n     * For non-expandable nodes, this is `null`.\n     */\n    _getAriaExpanded() {\n        if (!this._isExpandable()) {\n            return null;\n        }\n        return String(this.isExpanded);\n    }\n    /**\n     * Determines the size of this node's parent's child set.\n     *\n     * This is intended to be used for `aria-setsize`.\n     */\n    _getSetSize() {\n        return this._tree._getSetSize(this._data);\n    }\n    /**\n     * Determines the index (starting from 1) of this node in its parent's child set.\n     *\n     * This is intended to be used for `aria-posinset`.\n     */\n    _getPositionInSet() {\n        return this._tree._getPositionInSet(this._data);\n    }\n    constructor(_elementRef, _tree) {\n        this._elementRef = _elementRef;\n        this._tree = _tree;\n        this._tabindex = -1;\n        /** This emits when the node has been programatically activated or activated by keyboard. */\n        this.activation = new EventEmitter();\n        /** This emits when the node's expansion status has been changed. */\n        this.expandedChange = new EventEmitter();\n        /** Subject that emits when the component has been destroyed. */\n        this._destroyed = new Subject();\n        /** Emits when the node's data has changed. */\n        this._dataChanges = new Subject();\n        this._inputIsExpandable = false;\n        this._inputIsExpanded = undefined;\n        /**\n         * Flag used to determine whether or not we should be focusing the actual element based on\n         * some user interaction (click or focus). On click, we don't forcibly focus the element\n         * since the click could trigger some other component that wants to grab its own focus\n         * (e.g. menu, dialog).\n         */\n        this._shouldFocus = true;\n        this._changeDetectorRef = inject(ChangeDetectorRef);\n        CdkTreeNode.mostRecentTreeNode = this;\n    }\n    ngOnInit() {\n        this._parentNodeAriaLevel = getParentNodeAriaLevel(this._elementRef.nativeElement);\n        this._tree\n            ._getExpansionModel()\n            .changed.pipe(map(() => this.isExpanded), distinctUntilChanged())\n            .subscribe(() => {\n            this._changeDetectorRef.markForCheck();\n        });\n        this._tree._setNodeTypeIfUnset('flat');\n        this._tree._registerNode(this);\n    }\n    ngOnDestroy() {\n        // If this is the last tree node being destroyed,\n        // clear out the reference to avoid leaking memory.\n        if (CdkTreeNode.mostRecentTreeNode === this) {\n            CdkTreeNode.mostRecentTreeNode = null;\n        }\n        this._dataChanges.complete();\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    getParent() {\n        return this._tree._getNodeParent(this) ?? null;\n    }\n    getChildren() {\n        return this._tree._getNodeChildren(this);\n    }\n    /** Focuses this data node. Implemented for TreeKeyManagerItem. */\n    focus() {\n        this._tabindex = 0;\n        if (this._shouldFocus) {\n            this._elementRef.nativeElement.focus();\n        }\n        this._changeDetectorRef.markForCheck();\n    }\n    /** Defocus this data node. */\n    unfocus() {\n        this._tabindex = -1;\n        this._changeDetectorRef.markForCheck();\n    }\n    /** Emits an activation event. Implemented for TreeKeyManagerItem. */\n    activate() {\n        if (this.isDisabled) {\n            return;\n        }\n        this.activation.next(this._data);\n    }\n    /** Collapses this data node. Implemented for TreeKeyManagerItem. */\n    collapse() {\n        if (this.isExpandable) {\n            this._tree.collapse(this._data);\n        }\n    }\n    /** Expands this data node. Implemented for TreeKeyManagerItem. */\n    expand() {\n        if (this.isExpandable) {\n            this._tree.expand(this._data);\n        }\n    }\n    /** Makes the node focusable. Implemented for TreeKeyManagerItem. */\n    makeFocusable() {\n        this._tabindex = 0;\n        this._changeDetectorRef.markForCheck();\n    }\n    _focusItem() {\n        if (this.isDisabled) {\n            return;\n        }\n        this._tree._keyManager.focusItem(this);\n    }\n    _setActiveItem() {\n        if (this.isDisabled) {\n            return;\n        }\n        this._shouldFocus = false;\n        this._tree._keyManager.focusItem(this);\n        this._shouldFocus = true;\n    }\n    _emitExpansionState(expanded) {\n        this.expandedChange.emit(expanded);\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: CdkTreeNode, deps: [{ token: i0.ElementRef }, { token: CdkTree }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"16.1.0\", version: \"18.2.0-next.2\", type: CdkTreeNode, isStandalone: true, selector: \"cdk-tree-node\", inputs: { role: \"role\", isExpandable: [\"isExpandable\", \"isExpandable\", booleanAttribute], isExpanded: \"isExpanded\", isDisabled: [\"isDisabled\", \"isDisabled\", booleanAttribute], typeaheadLabel: [\"cdkTreeNodeTypeaheadLabel\", \"typeaheadLabel\"] }, outputs: { activation: \"activation\", expandedChange: \"expandedChange\" }, host: { attributes: { \"role\": \"treeitem\" }, listeners: { \"click\": \"_setActiveItem()\", \"focus\": \"_focusItem()\" }, properties: { \"attr.aria-expanded\": \"_getAriaExpanded()\", \"attr.aria-level\": \"level + 1\", \"attr.aria-posinset\": \"_getPositionInSet()\", \"attr.aria-setsize\": \"_getSetSize()\", \"tabindex\": \"_tabindex\" }, classAttribute: \"cdk-tree-node\" }, exportAs: [\"cdkTreeNode\"], ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: CdkTreeNode, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'cdk-tree-node',\n                    exportAs: 'cdkTreeNode',\n                    host: {\n                        'class': 'cdk-tree-node',\n                        '[attr.aria-expanded]': '_getAriaExpanded()',\n                        '[attr.aria-level]': 'level + 1',\n                        '[attr.aria-posinset]': '_getPositionInSet()',\n                        '[attr.aria-setsize]': '_getSetSize()',\n                        '[tabindex]': '_tabindex',\n                        'role': 'treeitem',\n                        '(click)': '_setActiveItem()',\n                        '(focus)': '_focusItem()',\n                    },\n                    standalone: true,\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: CdkTree }], propDecorators: { role: [{\n                type: Input\n            }], isExpandable: [{\n                type: Input,\n                args: [{ transform: booleanAttribute }]\n            }], isExpanded: [{\n                type: Input\n            }], isDisabled: [{\n                type: Input,\n                args: [{ transform: booleanAttribute }]\n            }], typeaheadLabel: [{\n                type: Input,\n                args: ['cdkTreeNodeTypeaheadLabel']\n            }], activation: [{\n                type: Output\n            }], expandedChange: [{\n                type: Output\n            }] } });\nfunction getParentNodeAriaLevel(nodeElement) {\n    let parent = nodeElement.parentElement;\n    while (parent && !isNodeElement(parent)) {\n        parent = parent.parentElement;\n    }\n    if (!parent) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            throw Error('Incorrect tree structure containing detached node.');\n        }\n        else {\n            return -1;\n        }\n    }\n    else if (parent.classList.contains('cdk-nested-tree-node')) {\n        return numberAttribute(parent.getAttribute('aria-level'));\n    }\n    else {\n        // The ancestor element is the cdk-tree itself\n        return 0;\n    }\n}\nfunction isNodeElement(element) {\n    const classList = element.classList;\n    return !!(classList?.contains('cdk-nested-tree-node') || classList?.contains('cdk-tree'));\n}\n\n/**\n * Nested node is a child of `<cdk-tree>`. It works with nested tree.\n * By using `cdk-nested-tree-node` component in tree node template, children of the parent node will\n * be added in the `cdkTreeNodeOutlet` in tree node template.\n * The children of node will be automatically added to `cdkTreeNodeOutlet`.\n */\nclass CdkNestedTreeNode extends CdkTreeNode {\n    constructor(elementRef, tree, _differs) {\n        super(elementRef, tree);\n        this._differs = _differs;\n    }\n    ngAfterContentInit() {\n        this._dataDiffer = this._differs.find([]).create(this._tree.trackBy);\n        this._tree\n            ._getDirectChildren(this.data)\n            .pipe(takeUntil(this._destroyed))\n            .subscribe(result => this.updateChildrenNodes(result));\n        this.nodeOutlet.changes\n            .pipe(takeUntil(this._destroyed))\n            .subscribe(() => this.updateChildrenNodes());\n    }\n    // This is a workaround for https://github.com/angular/angular/issues/23091\n    // In aot mode, the lifecycle hooks from parent class are not called.\n    ngOnInit() {\n        this._tree._setNodeTypeIfUnset('nested');\n        super.ngOnInit();\n    }\n    ngOnDestroy() {\n        this._clear();\n        super.ngOnDestroy();\n    }\n    /** Add children dataNodes to the NodeOutlet */\n    updateChildrenNodes(children) {\n        const outlet = this._getNodeOutlet();\n        if (children) {\n            this._children = children;\n        }\n        if (outlet && this._children) {\n            const viewContainer = outlet.viewContainer;\n            this._tree.renderNodeChanges(this._children, this._dataDiffer, viewContainer, this._data);\n        }\n        else {\n            // Reset the data differ if there's no children nodes displayed\n            this._dataDiffer.diff([]);\n        }\n    }\n    /** Clear the children dataNodes. */\n    _clear() {\n        const outlet = this._getNodeOutlet();\n        if (outlet) {\n            outlet.viewContainer.clear();\n            this._dataDiffer.diff([]);\n        }\n    }\n    /** Gets the outlet for the current node. */\n    _getNodeOutlet() {\n        const outlets = this.nodeOutlet;\n        // Note that since we use `descendants: true` on the query, we have to ensure\n        // that we don't pick up the outlet of a child node by accident.\n        return outlets && outlets.find(outlet => !outlet._node || outlet._node === this);\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: CdkNestedTreeNode, deps: [{ token: i0.ElementRef }, { token: CdkTree }, { token: i0.IterableDiffers }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"18.2.0-next.2\", type: CdkNestedTreeNode, isStandalone: true, selector: \"cdk-nested-tree-node\", host: { classAttribute: \"cdk-nested-tree-node\" }, providers: [\n            { provide: CdkTreeNode, useExisting: CdkNestedTreeNode },\n            { provide: CDK_TREE_NODE_OUTLET_NODE, useExisting: CdkNestedTreeNode },\n        ], queries: [{ propertyName: \"nodeOutlet\", predicate: CdkTreeNodeOutlet, descendants: true }], exportAs: [\"cdkNestedTreeNode\"], usesInheritance: true, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: CdkNestedTreeNode, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'cdk-nested-tree-node',\n                    exportAs: 'cdkNestedTreeNode',\n                    providers: [\n                        { provide: CdkTreeNode, useExisting: CdkNestedTreeNode },\n                        { provide: CDK_TREE_NODE_OUTLET_NODE, useExisting: CdkNestedTreeNode },\n                    ],\n                    host: {\n                        'class': 'cdk-nested-tree-node',\n                    },\n                    standalone: true,\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: CdkTree }, { type: i0.IterableDiffers }], propDecorators: { nodeOutlet: [{\n                type: ContentChildren,\n                args: [CdkTreeNodeOutlet, {\n                        // We need to use `descendants: true`, because Ivy will no longer match\n                        // indirect descendants if it's left as false.\n                        descendants: true,\n                    }]\n            }] } });\n\n/** Regex used to split a string on its CSS units. */\nconst cssUnitPattern = /([A-Za-z%]+)$/;\n/**\n * Indent for the children tree dataNodes.\n * This directive will add left-padding to the node to show hierarchy.\n */\nclass CdkTreeNodePadding {\n    /** The level of depth of the tree node. The padding will be `level * indent` pixels. */\n    get level() {\n        return this._level;\n    }\n    set level(value) {\n        this._setLevelInput(value);\n    }\n    /**\n     * The indent for each level. Can be a number or a CSS string.\n     * Default number 40px from material design menu sub-menu spec.\n     */\n    get indent() {\n        return this._indent;\n    }\n    set indent(indent) {\n        this._setIndentInput(indent);\n    }\n    constructor(_treeNode, _tree, _element, _dir) {\n        this._treeNode = _treeNode;\n        this._tree = _tree;\n        this._element = _element;\n        this._dir = _dir;\n        /** Subject that emits when the component has been destroyed. */\n        this._destroyed = new Subject();\n        /** CSS units used for the indentation value. */\n        this.indentUnits = 'px';\n        this._indent = 40;\n        this._setPadding();\n        if (_dir) {\n            _dir.change.pipe(takeUntil(this._destroyed)).subscribe(() => this._setPadding(true));\n        }\n        // In Ivy the indentation binding might be set before the tree node's data has been added,\n        // which means that we'll miss the first render. We have to subscribe to changes in the\n        // data to ensure that everything is up to date.\n        _treeNode._dataChanges.subscribe(() => this._setPadding());\n    }\n    ngOnDestroy() {\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /** The padding indent value for the tree node. Returns a string with px numbers if not null. */\n    _paddingIndent() {\n        const nodeLevel = (this._treeNode.data && this._tree._getLevel(this._treeNode.data)) ?? null;\n        const level = this._level == null ? nodeLevel : this._level;\n        return typeof level === 'number' ? `${level * this._indent}${this.indentUnits}` : null;\n    }\n    _setPadding(forceChange = false) {\n        const padding = this._paddingIndent();\n        if (padding !== this._currentPadding || forceChange) {\n            const element = this._element.nativeElement;\n            const paddingProp = this._dir && this._dir.value === 'rtl' ? 'paddingRight' : 'paddingLeft';\n            const resetProp = paddingProp === 'paddingLeft' ? 'paddingRight' : 'paddingLeft';\n            element.style[paddingProp] = padding || '';\n            element.style[resetProp] = '';\n            this._currentPadding = padding;\n        }\n    }\n    /**\n     * This has been extracted to a util because of TS 4 and VE.\n     * View Engine doesn't support property rename inheritance.\n     * TS 4.0 doesn't allow properties to override accessors or vice-versa.\n     * @docs-private\n     */\n    _setLevelInput(value) {\n        // Set to null as the fallback value so that _setPadding can fall back to the node level if the\n        // consumer set the directive as `cdkTreeNodePadding=\"\"`. We still want to take this value if\n        // they set 0 explicitly.\n        this._level = isNaN(value) ? null : value;\n        this._setPadding();\n    }\n    /**\n     * This has been extracted to a util because of TS 4 and VE.\n     * View Engine doesn't support property rename inheritance.\n     * TS 4.0 doesn't allow properties to override accessors or vice-versa.\n     * @docs-private\n     */\n    _setIndentInput(indent) {\n        let value = indent;\n        let units = 'px';\n        if (typeof indent === 'string') {\n            const parts = indent.split(cssUnitPattern);\n            value = parts[0];\n            units = parts[1] || units;\n        }\n        this.indentUnits = units;\n        this._indent = numberAttribute(value);\n        this._setPadding();\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: CdkTreeNodePadding, deps: [{ token: CdkTreeNode }, { token: CdkTree }, { token: i0.ElementRef }, { token: i2.Directionality, optional: true }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"16.1.0\", version: \"18.2.0-next.2\", type: CdkTreeNodePadding, isStandalone: true, selector: \"[cdkTreeNodePadding]\", inputs: { level: [\"cdkTreeNodePadding\", \"level\", numberAttribute], indent: [\"cdkTreeNodePaddingIndent\", \"indent\"] }, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: CdkTreeNodePadding, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkTreeNodePadding]',\n                    standalone: true,\n                }]\n        }], ctorParameters: () => [{ type: CdkTreeNode }, { type: CdkTree }, { type: i0.ElementRef }, { type: i2.Directionality, decorators: [{\n                    type: Optional\n                }] }], propDecorators: { level: [{\n                type: Input,\n                args: [{ alias: 'cdkTreeNodePadding', transform: numberAttribute }]\n            }], indent: [{\n                type: Input,\n                args: ['cdkTreeNodePaddingIndent']\n            }] } });\n\n/**\n * Node toggle to expand and collapse the node.\n */\nclass CdkTreeNodeToggle {\n    constructor(_tree, _treeNode) {\n        this._tree = _tree;\n        this._treeNode = _treeNode;\n        /** Whether expand/collapse the node recursively. */\n        this.recursive = false;\n    }\n    // Toggle the expanded or collapsed state of this node.\n    //\n    // Focus this node with expanding or collapsing it. This ensures that the active node will always\n    // be visible when expanding and collapsing.\n    _toggle() {\n        this.recursive\n            ? this._tree.toggleDescendants(this._treeNode.data)\n            : this._tree.toggle(this._treeNode.data);\n        this._tree._keyManager.focusItem(this._treeNode);\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: CdkTreeNodeToggle, deps: [{ token: CdkTree }, { token: CdkTreeNode }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"16.1.0\", version: \"18.2.0-next.2\", type: CdkTreeNodeToggle, isStandalone: true, selector: \"[cdkTreeNodeToggle]\", inputs: { recursive: [\"cdkTreeNodeToggleRecursive\", \"recursive\", booleanAttribute] }, host: { attributes: { \"tabindex\": \"-1\" }, listeners: { \"click\": \"_toggle(); $event.stopPropagation();\", \"keydown.Enter\": \"_toggle(); $event.preventDefault();\", \"keydown.Space\": \"_toggle(); $event.preventDefault();\" } }, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: CdkTreeNodeToggle, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkTreeNodeToggle]',\n                    host: {\n                        '(click)': '_toggle(); $event.stopPropagation();',\n                        '(keydown.Enter)': '_toggle(); $event.preventDefault();',\n                        '(keydown.Space)': '_toggle(); $event.preventDefault();',\n                        'tabindex': '-1',\n                    },\n                    standalone: true,\n                }]\n        }], ctorParameters: () => [{ type: CdkTree }, { type: CdkTreeNode }], propDecorators: { recursive: [{\n                type: Input,\n                args: [{ alias: 'cdkTreeNodeToggleRecursive', transform: booleanAttribute }]\n            }] } });\n\nconst EXPORTED_DECLARATIONS = [\n    CdkNestedTreeNode,\n    CdkTreeNodeDef,\n    CdkTreeNodePadding,\n    CdkTreeNodeToggle,\n    CdkTree,\n    CdkTreeNode,\n    CdkTreeNodeOutlet,\n];\nclass CdkTreeModule {\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: CdkTreeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }\n    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: CdkTreeModule, imports: [CdkNestedTreeNode,\n            CdkTreeNodeDef,\n            CdkTreeNodePadding,\n            CdkTreeNodeToggle,\n            CdkTree,\n            CdkTreeNode,\n            CdkTreeNodeOutlet], exports: [CdkNestedTreeNode,\n            CdkTreeNodeDef,\n            CdkTreeNodePadding,\n            CdkTreeNodeToggle,\n            CdkTree,\n            CdkTreeNode,\n            CdkTreeNodeOutlet] }); }\n    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: CdkTreeModule }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: CdkTreeModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: EXPORTED_DECLARATIONS,\n                    exports: EXPORTED_DECLARATIONS,\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BaseTreeControl, CDK_TREE_NODE_OUTLET_NODE, CdkNestedTreeNode, CdkTree, CdkTreeModule, CdkTreeNode, CdkTreeNodeDef, CdkTreeNodeOutlet, CdkTreeNodeOutletContext, CdkTreeNodePadding, CdkTreeNodeToggle, FlatTreeControl, NestedTreeControl, getMultipleTreeControlsError, getTreeControlMissingError, getTreeMissingMatchingNodeDefError, getTreeMultipleDefaultNodeDefsError, getTreeNoValidDataSourceError };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}