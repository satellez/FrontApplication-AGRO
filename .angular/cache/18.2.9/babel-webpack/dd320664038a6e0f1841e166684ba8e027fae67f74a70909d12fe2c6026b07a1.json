{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, Directive, NgModule } from '@angular/core';\nimport { isPlatformBrowser, DOCUMENT } from '@angular/common';\nimport { coerceElement } from '@angular/cdk/coercion';\nimport { getRtlScrollAxisType } from '@angular/cdk/platform';\nimport { Subject, merge, fromEvent, Observable, animationFrameScheduler, of } from 'rxjs';\nimport { take, expand, takeWhile, takeUntil, finalize } from 'rxjs/operators';\nimport BezierEasing from 'bezier-easing';\nconst SMOOTH_SCROLL_OPTIONS = new InjectionToken('SMOOTH_SCROLL_OPTIONS');\n\n// @dynamic\nclass SmoothScrollManager {\n  get _w() {\n    return this._document.defaultView;\n  }\n  /**\r\n   * Timing method\r\n   */\n  get _now() {\n    return this._w.performance && this._w.performance.now ? this._w.performance.now.bind(this._w.performance) : Date.now;\n  }\n  constructor(_document, _platform, customDefaultOptions) {\n    this._document = _document;\n    this._platform = _platform;\n    // Keeps track of the ongoing SmoothScroll functions so they can be handled in case of duplication.\n    // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.\n    // Purpose: If user called a scroll function again on the same element before the scrolls completes,\n    // it cancels the ongoing scroll and starts a new one\n    this._onGoingScrolls = new Map();\n    this._defaultOptions = {\n      duration: 468,\n      easing: {\n        x1: 0.42,\n        y1: 0,\n        x2: 0.58,\n        y2: 1\n      },\n      ...customDefaultOptions\n    };\n  }\n  /**\r\n   * changes scroll position inside an element\r\n   */\n  _scrollElement(el, x, y) {\n    el.scrollLeft = x;\n    el.scrollTop = y;\n  }\n  /**\r\n   * Handles a given parameter of type HTMLElement, ElementRef or selector\r\n   */\n  _getElement(el, parent) {\n    if (typeof el === 'string') {\n      return (parent || this._document).querySelector(el);\n    }\n    return coerceElement(el);\n  }\n  /**\r\n   * Initializes a destroyer stream, re-initializes it if the element is already being scrolled\r\n   */\n  _initSmoothScroll(el) {\n    if (this._onGoingScrolls.has(el)) {\n      this._onGoingScrolls.get(el).next();\n    }\n    return this._onGoingScrolls.set(el, new Subject()).get(el);\n  }\n  /**\r\n   * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise\r\n   */\n  _isFinished(context, destroyed, resolve) {\n    if (context.currentX !== context.x || context.currentY !== context.y) {\n      return true;\n    }\n    destroyed.next();\n    resolve();\n    return false;\n  }\n  /**\r\n   * Terminates an ongoing smooth scroll\r\n   */\n  _interrupted(el, destroyed) {\n    return merge(fromEvent(el, 'wheel', {\n      passive: true,\n      capture: true\n    }), fromEvent(el, 'touchmove', {\n      passive: true,\n      capture: true\n    }), destroyed).pipe(take(1));\n  }\n  /**\r\n   * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted\r\n   */\n  _destroy(el, destroyed) {\n    destroyed.complete();\n    this._onGoingScrolls.delete(el);\n  }\n  /**\r\n   * A function called recursively that, given a context, steps through scrolling\r\n   */\n  _step(context) {\n    return new Observable(subscriber => {\n      let elapsed = (this._now() - context.startTime) / context.duration;\n      // avoid elapsed times higher than one\n      elapsed = elapsed > 1 ? 1 : elapsed;\n      // apply easing to elapsed time\n      const value = context.easing(elapsed);\n      context.currentX = context.startX + (context.x - context.startX) * value;\n      context.currentY = context.startY + (context.y - context.startY) * value;\n      this._scrollElement(context.scrollable, context.currentX, context.currentY);\n      // Proceed to the step\n      animationFrameScheduler.schedule(() => subscriber.next(context));\n    });\n  }\n  _applyScrollToOptions(el, options) {\n    if (!options.duration) {\n      this._scrollElement(el, options.left, options.top);\n      return Promise.resolve();\n    }\n    // Initialize a destroyer stream, reinitialize it if the element is already being scrolled\n    const destroyed = this._initSmoothScroll(el);\n    const context = {\n      scrollable: el,\n      startTime: this._now(),\n      startX: el.scrollLeft,\n      startY: el.scrollTop,\n      x: options.left == null ? el.scrollLeft : ~~options.left,\n      y: options.top == null ? el.scrollTop : ~~options.top,\n      duration: options.duration,\n      easing: BezierEasing(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)\n    };\n    return new Promise(resolve => {\n      // Scroll each step recursively\n      of(null).pipe(expand(() => this._step(context).pipe(takeWhile(currContext => this._isFinished(currContext, destroyed, resolve)))), takeUntil(this._interrupted(el, destroyed)), finalize(() => this._destroy(el, destroyed))).subscribe();\n    });\n  }\n  /**\r\n   * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\r\n   * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\r\n   * left and right always refer to the left and right side of the scrolling container irrespective\r\n   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\r\n   * in an RTL context.\r\n   * @param scrollable element\r\n   * @param customOptions specified the offsets to scroll to.\r\n   */\n  scrollTo(scrollable, customOptions) {\n    if (isPlatformBrowser(this._platform)) {\n      const el = this._getElement(scrollable);\n      const isRtl = getComputedStyle(el).direction === 'rtl';\n      const rtlScrollAxisType = getRtlScrollAxisType();\n      const options = {\n        ...this._defaultOptions,\n        ...customOptions,\n        ...{\n          // Rewrite start & end offsets as right or left offsets.\n          left: customOptions.left == null ? isRtl ? customOptions.end : customOptions.start : customOptions.left,\n          right: customOptions.right == null ? isRtl ? customOptions.start : customOptions.end : customOptions.right\n        }\n      };\n      // Rewrite the bottom offset as a top offset.\n      if (options.bottom != null) {\n        options.top = el.scrollHeight - el.clientHeight - options.bottom;\n      }\n      // Rewrite the right offset as a left offset.\n      if (isRtl && rtlScrollAxisType !== 0 /* RtlScrollAxisType.NORMAL */) {\n        if (options.left != null) {\n          options.right = el.scrollWidth - el.clientWidth - options.left;\n        }\n        if (rtlScrollAxisType === 2 /* RtlScrollAxisType.INVERTED */) {\n          options.left = options.right;\n        } else if (rtlScrollAxisType === 1 /* RtlScrollAxisType.NEGATED */) {\n          options.left = options.right ? -options.right : options.right;\n        }\n      } else {\n        if (options.right != null) {\n          options.left = el.scrollWidth - el.clientWidth - options.right;\n        }\n      }\n      return this._applyScrollToOptions(el, options);\n    }\n    return Promise.resolve();\n  }\n  /**\r\n   * Scroll to element by reference or selector\r\n   */\n  scrollToElement(scrollable, target, customOptions = {}) {\n    const scrollableEl = this._getElement(scrollable);\n    const targetEl = this._getElement(target, scrollableEl);\n    const options = {\n      ...customOptions,\n      ...{\n        left: targetEl.offsetLeft + (customOptions.left || 0),\n        top: targetEl.offsetTop + (customOptions.top || 0)\n      }\n    };\n    return targetEl ? this.scrollTo(scrollableEl, options) : Promise.resolve();\n  }\n}\nSmoothScrollManager.ɵfac = function SmoothScrollManager_Factory(__ngFactoryType__) {\n  return new (__ngFactoryType__ || SmoothScrollManager)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(SMOOTH_SCROLL_OPTIONS, 8));\n};\nSmoothScrollManager.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: SmoothScrollManager,\n  factory: SmoothScrollManager.ɵfac,\n  providedIn: 'root'\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SmoothScrollManager, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [SMOOTH_SCROLL_OPTIONS]\n      }]\n    }];\n  }, null);\n})();\nclass SmoothScroll {\n  constructor(element, smoothScroll) {\n    this.element = element;\n    this.smoothScroll = smoothScroll;\n  }\n  scrollTo(options) {\n    return this.smoothScroll.scrollTo(this.element, options);\n  }\n  scrollToElement(target, options) {\n    return this.smoothScroll.scrollToElement(this.element, target, options);\n  }\n}\nSmoothScroll.ɵfac = function SmoothScroll_Factory(__ngFactoryType__) {\n  return new (__ngFactoryType__ || SmoothScroll)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(SmoothScrollManager));\n};\nSmoothScroll.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: SmoothScroll,\n  selectors: [[\"\", \"smoothScroll\", \"\"], [\"\", \"smooth-scroll\", \"\"]],\n  exportAs: [\"smoothScroll\"]\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SmoothScroll, [{\n    type: Directive,\n    args: [{\n      selector: '[smoothScroll], [smooth-scroll]',\n      exportAs: 'smoothScroll'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: SmoothScrollManager\n    }];\n  }, null);\n})();\nclass SmoothScrollModule {}\nSmoothScrollModule.ɵfac = function SmoothScrollModule_Factory(__ngFactoryType__) {\n  return new (__ngFactoryType__ || SmoothScrollModule)();\n};\nSmoothScrollModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: SmoothScrollModule\n});\nSmoothScrollModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SmoothScrollModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [SmoothScroll],\n      exports: [SmoothScroll]\n    }]\n  }], null, null);\n})();\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { SMOOTH_SCROLL_OPTIONS, SmoothScroll, SmoothScrollManager, SmoothScrollModule };","map":{"version":3,"names":["i0","InjectionToken","PLATFORM_ID","Injectable","Inject","Optional","Directive","NgModule","isPlatformBrowser","DOCUMENT","coerceElement","getRtlScrollAxisType","Subject","merge","fromEvent","Observable","animationFrameScheduler","of","take","expand","takeWhile","takeUntil","finalize","BezierEasing","SMOOTH_SCROLL_OPTIONS","SmoothScrollManager","_w","_document","defaultView","_now","performance","now","bind","Date","constructor","_platform","customDefaultOptions","_onGoingScrolls","Map","_defaultOptions","duration","easing","x1","y1","x2","y2","_scrollElement","el","x","y","scrollLeft","scrollTop","_getElement","parent","querySelector","_initSmoothScroll","has","get","next","set","_isFinished","context","destroyed","resolve","currentX","currentY","_interrupted","passive","capture","pipe","_destroy","complete","delete","_step","subscriber","elapsed","startTime","value","startX","startY","scrollable","schedule","_applyScrollToOptions","options","left","top","Promise","currContext","subscribe","scrollTo","customOptions","isRtl","getComputedStyle","direction","rtlScrollAxisType","end","start","right","bottom","scrollHeight","clientHeight","scrollWidth","clientWidth","scrollToElement","target","scrollableEl","targetEl","offsetLeft","offsetTop","ɵfac","SmoothScrollManager_Factory","__ngFactoryType__","ɵɵinject","ɵprov","ɵɵdefineInjectable","token","factory","providedIn","ngDevMode","ɵsetClassMetadata","type","args","Document","decorators","undefined","SmoothScroll","element","smoothScroll","SmoothScroll_Factory","ɵɵdirectiveInject","ElementRef","ɵdir","ɵɵdefineDirective","selectors","exportAs","selector","SmoothScrollModule","SmoothScrollModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","declarations","exports"],"sources":["D:/UNIVERSIDAD/TRABAJOS free/Oscar Robayo/front-agroconecta/node_modules/ngx-scrollbar/fesm2020/ngx-scrollbar-smooth-scroll.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, Directive, NgModule } from '@angular/core';\nimport { isPlatformBrowser, DOCUMENT } from '@angular/common';\nimport { coerceElement } from '@angular/cdk/coercion';\nimport { getRtlScrollAxisType } from '@angular/cdk/platform';\nimport { Subject, merge, fromEvent, Observable, animationFrameScheduler, of } from 'rxjs';\nimport { take, expand, takeWhile, takeUntil, finalize } from 'rxjs/operators';\nimport BezierEasing from 'bezier-easing';\n\nconst SMOOTH_SCROLL_OPTIONS = new InjectionToken('SMOOTH_SCROLL_OPTIONS');\n\n// @dynamic\r\nclass SmoothScrollManager {\r\n    get _w() {\r\n        return this._document.defaultView;\r\n    }\r\n    /**\r\n     * Timing method\r\n     */\r\n    get _now() {\r\n        return this._w.performance && this._w.performance.now\r\n            ? this._w.performance.now.bind(this._w.performance)\r\n            : Date.now;\r\n    }\r\n    constructor(_document, _platform, customDefaultOptions) {\r\n        this._document = _document;\r\n        this._platform = _platform;\r\n        // Keeps track of the ongoing SmoothScroll functions so they can be handled in case of duplication.\r\n        // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.\r\n        // Purpose: If user called a scroll function again on the same element before the scrolls completes,\r\n        // it cancels the ongoing scroll and starts a new one\r\n        this._onGoingScrolls = new Map();\r\n        this._defaultOptions = {\r\n            duration: 468,\r\n            easing: {\r\n                x1: 0.42,\r\n                y1: 0,\r\n                x2: 0.58,\r\n                y2: 1\r\n            },\r\n            ...customDefaultOptions,\r\n        };\r\n    }\r\n    /**\r\n     * changes scroll position inside an element\r\n     */\r\n    _scrollElement(el, x, y) {\r\n        el.scrollLeft = x;\r\n        el.scrollTop = y;\r\n    }\r\n    /**\r\n     * Handles a given parameter of type HTMLElement, ElementRef or selector\r\n     */\r\n    _getElement(el, parent) {\r\n        if (typeof el === 'string') {\r\n            return (parent || this._document).querySelector(el);\r\n        }\r\n        return coerceElement(el);\r\n    }\r\n    /**\r\n     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled\r\n     */\r\n    _initSmoothScroll(el) {\r\n        if (this._onGoingScrolls.has(el)) {\r\n            this._onGoingScrolls.get(el).next();\r\n        }\r\n        return this._onGoingScrolls.set(el, new Subject()).get(el);\r\n    }\r\n    /**\r\n     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise\r\n     */\r\n    _isFinished(context, destroyed, resolve) {\r\n        if (context.currentX !== context.x || context.currentY !== context.y) {\r\n            return true;\r\n        }\r\n        destroyed.next();\r\n        resolve();\r\n        return false;\r\n    }\r\n    /**\r\n     * Terminates an ongoing smooth scroll\r\n     */\r\n    _interrupted(el, destroyed) {\r\n        return merge(fromEvent(el, 'wheel', { passive: true, capture: true }), fromEvent(el, 'touchmove', { passive: true, capture: true }), destroyed).pipe(take(1));\r\n    }\r\n    /**\r\n     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted\r\n     */\r\n    _destroy(el, destroyed) {\r\n        destroyed.complete();\r\n        this._onGoingScrolls.delete(el);\r\n    }\r\n    /**\r\n     * A function called recursively that, given a context, steps through scrolling\r\n     */\r\n    _step(context) {\r\n        return new Observable((subscriber) => {\r\n            let elapsed = (this._now() - context.startTime) / context.duration;\r\n            // avoid elapsed times higher than one\r\n            elapsed = elapsed > 1 ? 1 : elapsed;\r\n            // apply easing to elapsed time\r\n            const value = context.easing(elapsed);\r\n            context.currentX = context.startX + (context.x - context.startX) * value;\r\n            context.currentY = context.startY + (context.y - context.startY) * value;\r\n            this._scrollElement(context.scrollable, context.currentX, context.currentY);\r\n            // Proceed to the step\r\n            animationFrameScheduler.schedule(() => subscriber.next(context));\r\n        });\r\n    }\r\n    _applyScrollToOptions(el, options) {\r\n        if (!options.duration) {\r\n            this._scrollElement(el, options.left, options.top);\r\n            return Promise.resolve();\r\n        }\r\n        // Initialize a destroyer stream, reinitialize it if the element is already being scrolled\r\n        const destroyed = this._initSmoothScroll(el);\r\n        const context = {\r\n            scrollable: el,\r\n            startTime: this._now(),\r\n            startX: el.scrollLeft,\r\n            startY: el.scrollTop,\r\n            x: options.left == null ? el.scrollLeft : ~~options.left,\r\n            y: options.top == null ? el.scrollTop : ~~options.top,\r\n            duration: options.duration,\r\n            easing: BezierEasing(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)\r\n        };\r\n        return new Promise(resolve => {\r\n            // Scroll each step recursively\r\n            of(null).pipe(expand(() => this._step(context).pipe(takeWhile((currContext) => this._isFinished(currContext, destroyed, resolve)))), takeUntil(this._interrupted(el, destroyed)), finalize(() => this._destroy(el, destroyed))).subscribe();\r\n        });\r\n    }\r\n    /**\r\n     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\r\n     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\r\n     * left and right always refer to the left and right side of the scrolling container irrespective\r\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\r\n     * in an RTL context.\r\n     * @param scrollable element\r\n     * @param customOptions specified the offsets to scroll to.\r\n     */\r\n    scrollTo(scrollable, customOptions) {\r\n        if (isPlatformBrowser(this._platform)) {\r\n            const el = this._getElement(scrollable);\r\n            const isRtl = getComputedStyle(el).direction === 'rtl';\r\n            const rtlScrollAxisType = getRtlScrollAxisType();\r\n            const options = {\r\n                ...this._defaultOptions,\r\n                ...customOptions,\r\n                ...{\r\n                    // Rewrite start & end offsets as right or left offsets.\r\n                    left: customOptions.left == null ? (isRtl ? customOptions.end : customOptions.start) : customOptions.left,\r\n                    right: customOptions.right == null ? (isRtl ? customOptions.start : customOptions.end) : customOptions.right\r\n                }\r\n            };\r\n            // Rewrite the bottom offset as a top offset.\r\n            if (options.bottom != null) {\r\n                options.top = el.scrollHeight - el.clientHeight - options.bottom;\r\n            }\r\n            // Rewrite the right offset as a left offset.\r\n            if (isRtl && rtlScrollAxisType !== 0 /* RtlScrollAxisType.NORMAL */) {\r\n                if (options.left != null) {\r\n                    options.right = el.scrollWidth - el.clientWidth - options.left;\r\n                }\r\n                if (rtlScrollAxisType === 2 /* RtlScrollAxisType.INVERTED */) {\r\n                    options.left = options.right;\r\n                }\r\n                else if (rtlScrollAxisType === 1 /* RtlScrollAxisType.NEGATED */) {\r\n                    options.left = options.right ? -options.right : options.right;\r\n                }\r\n            }\r\n            else {\r\n                if (options.right != null) {\r\n                    options.left = el.scrollWidth - el.clientWidth - options.right;\r\n                }\r\n            }\r\n            return this._applyScrollToOptions(el, options);\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    /**\r\n     * Scroll to element by reference or selector\r\n     */\r\n    scrollToElement(scrollable, target, customOptions = {}) {\r\n        const scrollableEl = this._getElement(scrollable);\r\n        const targetEl = this._getElement(target, scrollableEl);\r\n        const options = {\r\n            ...customOptions,\r\n            ...{\r\n                left: targetEl.offsetLeft + (customOptions.left || 0),\r\n                top: targetEl.offsetTop + (customOptions.top || 0)\r\n            }\r\n        };\r\n        return targetEl ? this.scrollTo(scrollableEl, options) : Promise.resolve();\r\n    }\r\n}\r\nSmoothScrollManager.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.1.4\", ngImport: i0, type: SmoothScrollManager, deps: [{ token: DOCUMENT }, { token: PLATFORM_ID }, { token: SMOOTH_SCROLL_OPTIONS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\r\nSmoothScrollManager.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.1.4\", ngImport: i0, type: SmoothScrollManager, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.1.4\", ngImport: i0, type: SmoothScrollManager, decorators: [{\r\n            type: Injectable,\r\n            args: [{\r\n                    providedIn: 'root'\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: Document, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [PLATFORM_ID]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Optional\r\n                }, {\r\n                    type: Inject,\r\n                    args: [SMOOTH_SCROLL_OPTIONS]\r\n                }] }]; } });\n\nclass SmoothScroll {\r\n    constructor(element, smoothScroll) {\r\n        this.element = element;\r\n        this.smoothScroll = smoothScroll;\r\n    }\r\n    scrollTo(options) {\r\n        return this.smoothScroll.scrollTo(this.element, options);\r\n    }\r\n    scrollToElement(target, options) {\r\n        return this.smoothScroll.scrollToElement(this.element, target, options);\r\n    }\r\n}\r\nSmoothScroll.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.1.4\", ngImport: i0, type: SmoothScroll, deps: [{ token: i0.ElementRef }, { token: SmoothScrollManager }], target: i0.ɵɵFactoryTarget.Directive });\r\nSmoothScroll.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"15.1.4\", type: SmoothScroll, selector: \"[smoothScroll], [smooth-scroll]\", exportAs: [\"smoothScroll\"], ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.1.4\", ngImport: i0, type: SmoothScroll, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: '[smoothScroll], [smooth-scroll]',\r\n                    exportAs: 'smoothScroll'\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: SmoothScrollManager }]; } });\n\nclass SmoothScrollModule {\r\n}\r\nSmoothScrollModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.1.4\", ngImport: i0, type: SmoothScrollModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\nSmoothScrollModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"15.1.4\", ngImport: i0, type: SmoothScrollModule, declarations: [SmoothScroll], exports: [SmoothScroll] });\r\nSmoothScrollModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"15.1.4\", ngImport: i0, type: SmoothScrollModule });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.1.4\", ngImport: i0, type: SmoothScrollModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    declarations: [SmoothScroll],\r\n                    exports: [SmoothScroll]\r\n                }]\r\n        }] });\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { SMOOTH_SCROLL_OPTIONS, SmoothScroll, SmoothScrollManager, SmoothScrollModule };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}